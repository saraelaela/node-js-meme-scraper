import * as JSX7 from '@eslint-react/jsx';
import { F, O, MutRef, isNullable, isString } from '@eslint-react/tools';
import { createRuleForPlugin, unsafeReadSettings } from '@eslint-react/shared';
import * as AST11 from '@eslint-react/ast';
import { isForwardRefCall, isThisSetState, isClassComponent, isChildrenCount, isChildrenForEach, isChildrenMap, isChildrenOnly, isChildrenToArray, useComponentCollectorLegacy, isCloneElementCall, isCreateRefCall, isComponentName, isChildrenToArrayCall, useComponentCollector, ERFunctionComponentFlag, ERComponentHint, isDirectValueOfRenderPropertyLoose, isDeclaredInRenderPropLoose, isInsideCreateElementProps, isInsideRenderMethod, ERClassComponentFlag, isFragmentElement, isCreateElementCall, isInitializedFromReact } from '@eslint-react/core';
import { AST_NODE_TYPES } from '@typescript-eslint/types';
import { isMatching, P, match } from 'ts-pattern';
import * as VAR from '@eslint-react/var';
import { getConstrainedTypeAtLocation, isTypeReadonly } from '@typescript-eslint/type-utils';
import { ESLintUtils } from '@typescript-eslint/utils';
import { getStaticValue } from '@typescript-eslint/utils/ast-utils';
import ts25 from 'typescript';
import { getTypeImmutability, isUnknown, isImmutable, isReadonlyShallow, isReadonlyDeep } from 'is-immutable-type';

// package.json
var name = "eslint-plugin-react-x";
var version = "1.14.0";
var createRule = createRuleForPlugin("x");

// src/rules/avoid-shorthand-boolean.ts
var RULE_NAME = "avoid-shorthand-boolean";
var avoid_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using shorthand boolean attributes"
    },
    messages: {
      avoidShorthandBoolean: "Avoid using shorthand boolean attribute '{{propName}}'. Use '{{propName}}={true}' instead."
    },
    schema: []
  },
  name: RULE_NAME,
  create(context) {
    function getReportDescriptor(node) {
      return node.value ? O.none() : O.some({
        messageId: "avoidShorthandBoolean",
        node,
        data: {
          propName: JSX7.getPropName(node)
        }
      });
    }
    return {
      JSXAttribute: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});

// src/rules/avoid-shorthand-fragment.ts
var RULE_NAME2 = "avoid-shorthand-fragment";
var avoid_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using shorthand fragment syntax"
    },
    messages: {
      avoidShorthandFragment: "Avoid using shorthand fragment syntax. Use 'Fragment' component instead."
    },
    schema: []
  },
  name: RULE_NAME2,
  create(context) {
    return {
      JSXFragment(node) {
        context.report({
          messageId: "avoidShorthandFragment",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME3 = "ensure-forward-ref-using-ref";
var ensure_forward_ref_using_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require a 'ref' parameter to be set when using 'forwardRef'"
    },
    messages: {
      ensureForwardRefUsingRef: "A 'forwardRef' is used with this component but no 'ref' parameter is set."
    },
    schema: []
  },
  name: RULE_NAME3,
  create(context) {
    return {
      CallExpression(node) {
        if (!isForwardRefCall(node, context)) return;
        const [component] = node.arguments;
        if (!component || !AST11.isFunction(component)) return;
        const [_, ref] = component.params;
        if (ref) return;
        context.report({
          messageId: "ensureForwardRefUsingRef",
          node: component
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME4 = "no-access-state-in-setstate";
function getName(node) {
  if (node.type === AST_NODE_TYPES.TSAsExpression) {
    return getName(node.expression);
  }
  if (node.type === AST_NODE_TYPES.Identifier || node.type === AST_NODE_TYPES.PrivateIdentifier) {
    return O.some(node.name);
  }
  if (node.type === AST_NODE_TYPES.Literal) {
    return O.some(String(node.value));
  }
  if (node.type === AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return O.fromNullable(node.quasis[0]?.value.raw);
  }
  return O.none();
}
var no_access_state_in_setstate_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow accessing 'this.state' within 'setState'"
    },
    messages: {
      noAccessStateInSetstate: "Do not access 'this.state' within 'setState'. Use the update function instead."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    if (!context.sourceCode.text.includes("setState")) return {};
    const classStack = [];
    const methodStack = [];
    const setStateStack = [];
    return {
      CallExpression(node) {
        if (!isThisSetState(node)) return;
        setStateStack.push([node, false]);
      },
      "CallExpression:exit"(node) {
        if (!isThisSetState(node)) return;
        setStateStack.pop();
      },
      ClassDeclaration(node) {
        classStack.push([node, isClassComponent(node)]);
      },
      "ClassDeclaration:exit"() {
        classStack.pop();
      },
      ClassExpression(node) {
        classStack.push([node, isClassComponent(node)]);
      },
      "ClassExpression:exit"() {
        classStack.pop();
      },
      MemberExpression(node) {
        if (!AST11.isThisExpression(node.object)) return;
        const [currClass, isComponent] = classStack.at(-1) ?? [];
        if (!currClass || !isComponent) return;
        const [currMethod, isStatic] = methodStack.at(-1) ?? [];
        if (!currMethod || isStatic) return;
        const [setState, hasThisState] = setStateStack.at(-1) ?? [];
        if (!setState || hasThisState) return;
        if (!O.exists(getName(node.property), (name2) => name2 === "state")) return;
        context.report({ messageId: "noAccessStateInSetstate", node });
      },
      MethodDefinition(node) {
        methodStack.push([node, node.static]);
      },
      "MethodDefinition:exit"() {
        methodStack.pop();
      },
      PropertyDefinition(node) {
        methodStack.push([node, node.static]);
      },
      "PropertyDefinition:exit"() {
        methodStack.pop();
      },
      VariableDeclarator(node) {
        const [currClass, isComponent] = classStack.at(-1) ?? [];
        if (!currClass || !isComponent) return;
        const [currMethod, isStatic] = methodStack.at(-1) ?? [];
        if (!currMethod || isStatic) return;
        const [setState, hasThisState] = setStateStack.at(-1) ?? [];
        if (!setState || hasThisState) return;
        if (!(node.init && AST11.isThisExpression(node.init) && node.id.type === AST_NODE_TYPES.ObjectPattern)) return;
        const hasState = node.id.properties.some((prop) => {
          if (prop.type === AST_NODE_TYPES.Property && AST11.isKeyLiteralLike(prop, prop.key)) {
            return O.exists(getName(prop.key), (name2) => name2 === "state");
          }
          return false;
        });
        if (!hasState) return;
        context.report({ messageId: "noAccessStateInSetstate", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME5 = "no-array-index-key";
var reactChildrenMethod = ["forEach", "map"];
var iteratorFunctionIndexParamPosition = /* @__PURE__ */ new Map([
  ["every", 1],
  ["filter", 1],
  ["find", 1],
  ["findIndex", 1],
  ["findLast", 1],
  ["findLastIndex", 1],
  ["flatMap", 1],
  ["forEach", 1],
  ["map", 1],
  ["reduce", 2],
  ["reduceRight", 2],
  ["some", 1]
]);
var isToStringCall = isMatching({
  type: AST_NODE_TYPES.CallExpression,
  callee: {
    type: AST_NODE_TYPES.MemberExpression,
    property: {
      type: AST_NODE_TYPES.Identifier,
      name: "toString"
    }
  }
});
function isReactChildrenMethod(name2) {
  return reactChildrenMethod.some((method) => method === name2);
}
function isUsingReactChildren(node, context) {
  const settings = unsafeReadSettings(context.settings);
  const { callee } = node;
  if (!("property" in callee) || !("object" in callee) || !("name" in callee.property)) {
    return false;
  }
  if (!isReactChildrenMethod(callee.property.name)) return false;
  const initialScope = context.sourceCode.getScope(node);
  if (callee.object.type === AST_NODE_TYPES.Identifier && callee.object.name === "Children") return true;
  if (callee.object.type === AST_NODE_TYPES.MemberExpression && "name" in callee.object.object) {
    return isInitializedFromReact(callee.object.object.name, initialScope, settings);
  }
  return false;
}
function getMapIndexParamName(node, context) {
  const { callee } = node;
  if (callee.type !== AST_NODE_TYPES.MemberExpression) return O.none();
  if (callee.property.type !== AST_NODE_TYPES.Identifier) return O.none();
  const { name: name2 } = callee.property;
  if (!iteratorFunctionIndexParamPosition.has(name2)) return O.none();
  const callbackArg = node.arguments[isUsingReactChildren(node, context) ? 1 : 0];
  if (!callbackArg) return O.none();
  if (!AST11.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(callbackArg)) {
    return O.none();
  }
  const { params } = callbackArg;
  const indexParamPosition = iteratorFunctionIndexParamPosition.get(name2);
  if (isNullable(indexParamPosition)) return O.none();
  if (params.length < indexParamPosition + 1) return O.none();
  const param = params.at(indexParamPosition);
  return param && "name" in param ? O.some(param.name) : O.none();
}
var no_array_index_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using Array index as 'key'"
    },
    messages: {
      noArrayIndexKey: "Do not use Array index as 'key'."
    },
    schema: []
  },
  name: RULE_NAME5,
  create(context) {
    const indexParamNames = [];
    function isArrayIndex(node) {
      return node.type === AST_NODE_TYPES.Identifier && indexParamNames.some(O.exists((name2) => name2 === node.name));
    }
    function isCreateOrCloneElementCall(node) {
      return isCreateElementCall(node, context) || isCloneElementCall(node, context);
    }
    function getReportDescriptor(node) {
      if (isArrayIndex(node)) return [{ messageId: "noArrayIndexKey", node }];
      if (AST11.isOneOf([AST_NODE_TYPES.TemplateLiteral, AST_NODE_TYPES.BinaryExpression])(node)) {
        const exps = AST_NODE_TYPES.TemplateLiteral === node.type ? node.expressions : AST11.getIdentifiersFromBinaryExpression(node);
        return exps.reduce((acc, exp) => {
          if (isArrayIndex(exp)) return [...acc, { messageId: "noArrayIndexKey", node: exp }];
          return acc;
        }, []);
      }
      if (isToStringCall(node)) {
        if (!("object" in node.callee && isArrayIndex(node.callee.object))) return [];
        return [{ messageId: "noArrayIndexKey", node: node.callee.object }];
      }
      const isStringCall = isMatching({
        type: AST_NODE_TYPES.CallExpression,
        callee: {
          type: AST_NODE_TYPES.Identifier,
          name: "String"
        }
      }, node);
      if (isStringCall) {
        const [arg] = node.arguments;
        if (arg && isArrayIndex(arg)) return [{ messageId: "noArrayIndexKey", node: arg }];
      }
      return [];
    }
    return {
      CallExpression(node) {
        indexParamNames.push(getMapIndexParamName(node, context));
        if (node.arguments.length === 0) return;
        if (!isCreateOrCloneElementCall(node)) return;
        const [_, props] = node.arguments;
        if (props?.type !== AST_NODE_TYPES.ObjectExpression) return;
        for (const prop of props.properties) {
          if (!isMatching({ key: { name: "key" } }, prop)) continue;
          if (!("value" in prop)) continue;
          const descriptors = getReportDescriptor(prop.value);
          for (const descriptor of descriptors) {
            context.report(descriptor);
          }
        }
      },
      "CallExpression:exit"() {
        indexParamNames.pop();
      },
      JSXAttribute(node) {
        if (node.name.name !== "key") return;
        if (indexParamNames.length === 0) return;
        const { value } = node;
        if (value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
        const descriptors = getReportDescriptor(value.expression);
        for (const descriptor of descriptors) {
          context.report(descriptor);
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME6 = "no-children-count";
var no_children_count_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.count'"
    },
    messages: {
      noChildrenCount: "Using 'Children.count' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME6,
  create(context) {
    return {
      MemberExpression(node) {
        if (isChildrenCount(node, context)) {
          context.report({
            messageId: "noChildrenCount",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME7 = "no-children-for-each";
var no_children_for_each_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.forEach'"
    },
    messages: {
      noChildrenForEach: "Using 'Children.forEach' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME7,
  create(context) {
    return {
      MemberExpression(node) {
        if (isChildrenForEach(node, context)) {
          context.report({
            messageId: "noChildrenForEach",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME8 = "no-children-map";
var no_children_map_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.map'"
    },
    messages: {
      noChildrenMap: "Using 'Children.map' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME8,
  create(context) {
    return {
      MemberExpression(node) {
        if (isChildrenMap(node, context)) {
          context.report({
            messageId: "noChildrenMap",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME9 = "no-children-only";
var no_children_only_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.only'"
    },
    messages: {
      noChildrenOnly: "Using 'Children.only' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME9,
  create(context) {
    return {
      MemberExpression(node) {
        if (isChildrenOnly(node, context)) {
          context.report({
            messageId: "noChildrenOnly",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME10 = "no-children-prop";
var no_children_prop_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing 'children' as props"
    },
    messages: {
      noChildrenProp: "Do not pass 'children' as props."
    },
    schema: []
  },
  name: RULE_NAME10,
  create(context) {
    return {
      JSXElement(node) {
        const initialScope = context.sourceCode.getScope(node);
        const prop = JSX7.getProp(node.openingElement.attributes, "children", initialScope);
        const reportDescriptor = O.map(prop, (prop2) => ({ messageId: "noChildrenProp", node: prop2 }));
        O.map(reportDescriptor, context.report);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME11 = "no-children-to-array";
var no_children_to_array_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.toArray'"
    },
    messages: {
      noChildrenToArray: "Using 'Children.toArray' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME11,
  create(context) {
    return {
      MemberExpression(node) {
        if (isChildrenToArray(node, context)) {
          context.report({
            messageId: "noChildrenToArray",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME12 = "no-class-component";
var isComponentDidCatch = isMatching({
  key: {
    type: AST_NODE_TYPES.Identifier,
    name: "componentDidCatch"
  },
  type: P.union(AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition),
  static: false
});
var isGetDerivedStateFromError = isMatching({
  key: {
    type: AST_NODE_TYPES.Identifier,
    name: "getDerivedStateFromError"
  },
  type: P.union(AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition),
  static: true
});
var no_class_component_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using class components"
    },
    messages: {
      noClassComponent: "Do not use class components. Use function components instead."
    },
    schema: []
  },
  name: RULE_NAME12,
  create(context) {
    if (!context.sourceCode.text.includes("Component")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { name: name2, node: component } of components.values()) {
          if (component.body.body.some((m) => isComponentDidCatch(m) || isGetDerivedStateFromError(m))) continue;
          context.report({
            messageId: "noClassComponent",
            node: component,
            data: {
              // eslint-disable-next-line eslint-plugin/no-unused-placeholders
              name: O.getOrElse(F.constant("anonymous"))(name2)
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME13 = "no-clone-element";
var no_clone_element_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'cloneElement'"
    },
    messages: {
      noCloneElement: "Using 'cloneElement' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME13,
  create(context) {
    return {
      CallExpression(node) {
        if (!isCloneElementCall(node, context)) return;
        context.report({
          messageId: "noCloneElement",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME14 = "no-comment-textnodes";
var no_comment_textnodes_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow comments from being inserted as text nodes"
    },
    messages: {
      noCommentTextnodes: "Possible misused comment in text node. Comments inside children section of tag should be placed inside braces."
    },
    schema: []
  },
  name: RULE_NAME14,
  create(context) {
    function hasCommentLike(node) {
      if (AST11.isOneOf([AST_NODE_TYPES.JSXAttribute, AST_NODE_TYPES.JSXExpressionContainer])(node.parent)) return false;
      const rawValue = context.sourceCode.getText(node);
      return /^\s*\/(?:\/|\*)/mu.test(rawValue);
    }
    const getReportDescriptor = (node) => {
      if (!AST11.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent)) return O.none();
      if (!hasCommentLike(node)) return O.none();
      if (!node.parent.type.includes("JSX")) return O.none();
      return O.some({
        messageId: "noCommentTextnodes",
        node
      });
    };
    const ruleFunction = F.flow(getReportDescriptor, O.map(context.report), F.constVoid);
    return {
      JSXText: ruleFunction,
      Literal: ruleFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME15 = "no-complex-conditional-rendering";
var no_complex_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow complex conditional rendering"
    },
    messages: {
      noComplexConditionalRendering: "Avoid complex conditional rendering. Extract the logic into separate elements or components."
    },
    schema: []
  },
  name: RULE_NAME15,
  create(context) {
    function getReportDescriptor(node) {
      const jsxExpContainer = node.parent?.parent;
      if (!AST11.is(AST_NODE_TYPES.JSXExpressionContainer)(jsxExpContainer)) return O.none();
      if (!AST11.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(jsxExpContainer.parent)) {
        return O.none();
      }
      if (!jsxExpContainer.parent.children.includes(jsxExpContainer)) return O.none();
      return O.some({ messageId: "noComplexConditionalRendering", node: jsxExpContainer });
    }
    const ruleFunction = F.flow(getReportDescriptor, O.map(context.report), F.constVoid);
    return {
      "JSXExpressionContainer > ConditionalExpression > ConditionalExpression": ruleFunction,
      "JSXExpressionContainer > ConditionalExpression > LogicalExpression": ruleFunction,
      "JSXExpressionContainer > LogicalExpression > ConditionalExpression": ruleFunction,
      "JSXExpressionContainer > LogicalExpression[operator='&&'] > LogicalExpression[operator='||']": ruleFunction,
      "JSXExpressionContainer > LogicalExpression[operator='||'] > LogicalExpression[operator='&&']": ruleFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME16 = "no-component-will-mount";
function isComponentWillMount(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillMount";
}
var no_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'componentWillMount'"
    },
    messages: {
      noComponentWillMount: "[Deprecated] Use 'UNSAFE_componentWillMount' instead."
    },
    schema: []
  },
  name: RULE_NAME16,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillMount")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillMount(member)) {
              context.report({
                messageId: "noComponentWillMount",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME17 = "no-component-will-receive-props";
function isComponentWillUpdate(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillReceiveProps";
}
var no_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'componentWillReceiveProps'"
    },
    messages: {
      noComponentWillReceiveProps: "[Deprecated] Use 'UNSAFE_componentWillReceiveProps' instead."
    },
    schema: []
  },
  name: RULE_NAME17,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillReceiveProps")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillUpdate(member)) {
              context.report({
                messageId: "noComponentWillReceiveProps",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME18 = "no-component-will-update";
function isComponentWillUpdate2(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
var no_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'componentWillReceiveProps'"
    },
    messages: {
      noComponentWillUpdate: "[Deprecated] Use 'UNSAFE_componentWillUpdate' instead."
    },
    schema: []
  },
  name: RULE_NAME18,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillUpdate2(member)) {
              context.report({
                messageId: "noComponentWillUpdate",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME19 = "no-create-ref";
var no_create_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'createRef' in function components"
    },
    messages: {
      noCreateRef: "[Deprecated] Use 'useRef' instead."
    },
    schema: []
  },
  name: RULE_NAME19,
  create(context) {
    return {
      CallExpression(node) {
        if (!isCreateRefCall(node, context)) return;
        if (O.isSome(AST11.traverseUp(node, isClassComponent))) return;
        context.report({ messageId: "noCreateRef", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME20 = "no-default-props";
var no_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'defaultProps' property in components"
    },
    messages: {
      noDefaultProps: "[Deprecated] Use ES6 default parameters instead."
    },
    schema: []
  },
  name: RULE_NAME20,
  create(context) {
    if (!context.sourceCode.text.includes("defaultProps")) return {};
    return {
      AssignmentExpression(node) {
        if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) return;
        const { object, property } = node.left;
        if (object.type !== AST_NODE_TYPES.Identifier) return;
        if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "defaultProps") return;
        if (!isComponentName(object.name)) return;
        const isComponent = F.pipe(
          VAR.findVariable(object.name, context.sourceCode.getScope(node)),
          O.flatMap(VAR.getVariableNode(0)),
          O.exists((n) => AST11.isFunction(n) || isClassComponent(n))
        );
        if (!isComponent) return;
        context.report({ messageId: "noDefaultProps", node: property });
      },
      PropertyDefinition(node) {
        if (!isClassComponent(node.parent.parent)) return;
        if (!node.static || node.key.type !== AST_NODE_TYPES.Identifier || node.key.name !== "defaultProps") return;
        context.report({ messageId: "noDefaultProps", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME21 = "no-direct-mutation-state";
function getName2(node) {
  if (node.type === AST_NODE_TYPES.TSAsExpression) {
    return getName2(node.expression);
  }
  if (node.type === AST_NODE_TYPES.Identifier || node.type === AST_NODE_TYPES.PrivateIdentifier) {
    return O.some(node.name);
  }
  if (node.type === AST_NODE_TYPES.Literal) {
    return O.some(String(node.value));
  }
  if (node.type === AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return O.fromNullable(node.quasis[0]?.value.raw);
  }
  return O.none();
}
function isAssignmentToThisState(node) {
  const { left } = node;
  return left.type === AST_NODE_TYPES.MemberExpression && AST11.isThisExpression(left.object) && O.exists(getName2(left.property), (name2) => name2 === "state");
}
function isConstructorFunction(node) {
  return AST11.isOneOf([AST_NODE_TYPES.FunctionDeclaration, AST_NODE_TYPES.FunctionExpression])(node) && AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node.parent) && node.parent.key.type === AST_NODE_TYPES.Identifier && node.parent.key.name === "constructor";
}
var no_direct_mutation_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow direct mutation of state"
    },
    messages: {
      noDirectMutationState: "Do not mutate state directly. Use 'setState()' instead."
    },
    schema: []
  },
  name: RULE_NAME21,
  create(context) {
    function getReportDescriptor(node) {
      if (!isAssignmentToThisState(node)) return O.none();
      const maybeParentClass = AST11.traverseUpGuard(
        node,
        AST11.isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression])
      );
      if (O.isNone(maybeParentClass)) return O.none();
      const parentClass = maybeParentClass.value;
      if (!isClassComponent(parentClass)) return O.none();
      const maybeParentConstructor = AST11.traverseUpGuard(node, isConstructorFunction);
      if (O.exists(maybeParentConstructor, (n) => context.sourceCode.getScope(node).block === n)) return O.none();
      return O.some({
        messageId: "noDirectMutationState",
        node
      });
    }
    return {
      AssignmentExpression: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME22 = "no-duplicate-key";
var no_duplicate_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate keys when rendering list"
    },
    messages: {
      noDuplicateKey: "A key must be unique. '{{value}}' is duplicated."
    },
    schema: []
  },
  name: RULE_NAME22,
  create(context) {
    const isWithinChildrenToArrayRef = MutRef.make(false);
    function isKeyEqual(a, b) {
      return VAR.isNodeValueEqual(a, b, [context.sourceCode.getScope(a), context.sourceCode.getScope(b)]);
    }
    function checkIteratorElement(node) {
      if (node.type !== AST_NODE_TYPES.JSXElement) return O.none();
      const initialScope = context.sourceCode.getScope(node);
      return F.pipe(
        JSX7.findPropInAttributes(node.openingElement.attributes, initialScope)("key"),
        O.flatMap((k) => "value" in k ? O.fromNullable(k.value) : O.none()),
        O.flatMap((v) => {
          return isKeyEqual(v, v) ? O.some({
            messageId: "noDuplicateKey",
            node: v,
            data: {
              value: context.sourceCode.getText(v)
            }
          }) : O.none();
        })
      );
    }
    function checkExpression(node) {
      switch (node.type) {
        case AST_NODE_TYPES.JSXElement:
        case AST_NODE_TYPES.JSXFragment:
          return checkIteratorElement(node);
        case AST_NODE_TYPES.ConditionalExpression:
          if (!("consequent" in node)) return O.none();
          return F.pipe(
            checkIteratorElement(node.consequent),
            O.orElse(() => checkIteratorElement(node.alternate))
          );
        case AST_NODE_TYPES.LogicalExpression:
          if (!("left" in node)) return O.none();
          return F.pipe(
            checkIteratorElement(node.left),
            O.orElse(() => checkIteratorElement(node.right))
          );
        default:
          return O.none();
      }
    }
    function checkBlockStatement(node) {
      return AST11.getNestedReturnStatements(node).reduce((acc, statement) => {
        if (!statement.argument) return acc;
        const maybeDescriptor = checkIteratorElement(statement.argument);
        if (O.isNone(maybeDescriptor)) return acc;
        const descriptor = maybeDescriptor.value;
        return [...acc, descriptor];
      }, []);
    }
    const seen = /* @__PURE__ */ new WeakSet();
    return {
      "ArrayExpression, JSXElement > JSXElement"(node) {
        if (MutRef.get(isWithinChildrenToArrayRef)) return;
        const elements = match(node).with({ type: AST_NODE_TYPES.ArrayExpression }, ({ elements: elements2 }) => elements2).with({ type: AST_NODE_TYPES.JSXElement }, ({ parent }) => "children" in parent ? parent.children : []).otherwise(() => []).filter(AST11.is(AST_NODE_TYPES.JSXElement)).filter((element) => !seen.has(element));
        const keys = elements.reduce(
          (acc, element) => {
            const attr = element.openingElement.attributes.findLast((attr2) => {
              if (attr2.type !== AST_NODE_TYPES.JSXAttribute) return false;
              return attr2.name.name === "key";
            });
            if (!attr || !("value" in attr) || attr.value === null) return acc;
            const { value } = attr;
            if (acc.length === 0) return [[element, attr, value]];
            if (acc.some(([_, _1, v]) => isKeyEqual(v, value))) {
              return [...acc, [element, attr, value]];
            }
            return acc;
          },
          []
        );
        if (keys.length < 2) return;
        for (const [element, attr, value] of keys) {
          seen.add(element);
          context.report({
            messageId: "noDuplicateKey",
            node: attr,
            data: {
              value: context.sourceCode.getText(value)
            }
          });
        }
      },
      CallExpression(node) {
        if (isChildrenToArrayCall(node, context)) MutRef.set(isWithinChildrenToArrayRef, true);
        const isMapCall = AST11.isMapCallLoose(node);
        const isArrayFromCall = isMatching({
          type: AST_NODE_TYPES.CallExpression,
          callee: {
            type: AST_NODE_TYPES.MemberExpression,
            property: {
              name: "from"
            }
          }
        }, node);
        if (!isMapCall && !isArrayFromCall) return;
        if (MutRef.get(isWithinChildrenToArrayRef)) return;
        const fn = node.arguments[isMapCall ? 0 : 1];
        if (!AST11.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(fn)) return;
        if (fn.body.type === AST_NODE_TYPES.BlockStatement) {
          for (const descriptor of checkBlockStatement(fn.body)) {
            context.report(descriptor);
          }
          return;
        }
        O.map(checkExpression(fn.body), context.report);
      },
      "CallExpression:exit"(node) {
        if (isChildrenToArrayCall(node, context)) MutRef.set(isWithinChildrenToArrayRef, false);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME23 = "no-implicit-key";
var no_implicit_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow implicit 'key' props"
    },
    messages: {
      noImplicitKey: "Do not use implicit 'key' props."
    },
    schema: []
  },
  name: RULE_NAME23,
  create(context) {
    function getReportDescriptor(node) {
      const initialScope = context.sourceCode.getScope(node);
      const keyPropFound = JSX7.findPropInAttributes(node.attributes, initialScope)("key");
      const keyPropOnElement = node.attributes.some(
        (n) => AST11.is(AST_NODE_TYPES.JSXAttribute)(n) && n.name.name === "key"
      );
      if (O.isSome(keyPropFound) && !keyPropOnElement) {
        return O.some({ messageId: "noImplicitKey", node: keyPropFound.value });
      }
      return O.none();
    }
    return {
      JSXOpeningElement: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});
function isFlagSet(allFlags, flag) {
  return (allFlags & flag) !== 0;
}
function isFlagSetOnObject(obj, flag) {
  return isFlagSet(obj.flags, flag);
}
var isTypeFlagSet = isFlagSetOnObject;
ts25.versionMajorMinor.split(".").map((raw) => Number.parseInt(raw, 10));
ts25.TypeFlags.Intrinsic ?? ts25.TypeFlags.Any | ts25.TypeFlags.Unknown | ts25.TypeFlags.String | ts25.TypeFlags.Number | ts25.TypeFlags.BigInt | ts25.TypeFlags.Boolean | ts25.TypeFlags.BooleanLiteral | ts25.TypeFlags.ESSymbol | ts25.TypeFlags.Void | ts25.TypeFlags.Undefined | ts25.TypeFlags.Null | ts25.TypeFlags.Never | ts25.TypeFlags.NonPrimitive;
function isUnionType(type) {
  return isTypeFlagSet(type, ts25.TypeFlags.Union);
}
function isBooleanLiteralType(type) {
  return isTypeFlagSet(type, ts25.TypeFlags.BooleanLiteral);
}
function isFalseLiteralType(type) {
  return isBooleanLiteralType(type) && type.intrinsicName === "false";
}
function isTrueLiteralType(type) {
  return isBooleanLiteralType(type) && type.intrinsicName === "true";
}
function unionTypeParts(type) {
  return isUnionType(type) ? type.types : [type];
}
var RULE_NAME24 = "no-leaked-conditional-rendering";
var allowedVariants = [
  "any",
  "boolean",
  "nullish",
  "object",
  "string",
  "falsy string",
  "falsy boolean",
  "truthy bigint",
  "truthy boolean",
  "truthy number",
  "truthy string"
];
var tsHelpers = {
  isAnyType: (type) => isTypeFlagSet(type, ts25.TypeFlags.TypeParameter | ts25.TypeFlags.Any),
  isBigIntType: (type) => isTypeFlagSet(type, ts25.TypeFlags.BigIntLike),
  isBooleanType: (type) => isTypeFlagSet(type, ts25.TypeFlags.BooleanLike),
  isEnumType: (type) => isTypeFlagSet(type, ts25.TypeFlags.EnumLike),
  isFalsyBigIntType: (type) => type.isLiteral() && isMatching({ value: { base10Value: "0" } }, type),
  isFalsyNumberType: (type) => type.isNumberLiteral() && type.value === 0,
  isFalsyStringType: (type) => type.isStringLiteral() && type.value === "",
  isNeverType: (type) => isTypeFlagSet(type, ts25.TypeFlags.Never),
  isNullishType: (type) => isTypeFlagSet(
    type,
    ts25.TypeFlags.Null | ts25.TypeFlags.Undefined | ts25.TypeFlags.VoidLike
  ),
  isNumberType: (type) => isTypeFlagSet(type, ts25.TypeFlags.NumberLike),
  isObjectType: (type) => !isTypeFlagSet(
    type,
    ts25.TypeFlags.Null | ts25.TypeFlags.Undefined | ts25.TypeFlags.VoidLike | ts25.TypeFlags.BooleanLike | ts25.TypeFlags.StringLike | ts25.TypeFlags.NumberLike | ts25.TypeFlags.BigIntLike | ts25.TypeFlags.TypeParameter | ts25.TypeFlags.Any | ts25.TypeFlags.Unknown | ts25.TypeFlags.Never
  ),
  isStringType: (type) => isTypeFlagSet(type, ts25.TypeFlags.StringLike),
  isTruthyBigIntType: (type) => type.isLiteral() && isMatching({ value: { base10Value: P.not("0") } }, type),
  isTruthyNumberType: (type) => type.isNumberLiteral() && type.value !== 0,
  isTruthyStringType: (type) => type.isStringLiteral() && type.value !== "",
  isUnknownType: (type) => isTypeFlagSet(type, ts25.TypeFlags.Unknown)
};
function inspectVariantTypes(types) {
  const variantTypes = /* @__PURE__ */ new Set();
  if (types.some(tsHelpers.isUnknownType)) {
    variantTypes.add("unknown");
    return variantTypes;
  }
  if (types.some(tsHelpers.isNullishType)) {
    variantTypes.add("nullish");
  }
  const booleans = types.filter(tsHelpers.isBooleanType);
  switch (true) {
    case (booleans.length === 1 && !!booleans[0]): {
      const [first] = booleans;
      const evaluated = F.pipe(
        match(first).when(isTrueLiteralType, () => O.some("truthy boolean")).when(isFalseLiteralType, () => O.some("falsy boolean")).otherwise(O.none)
      );
      O.map(evaluated, (v) => variantTypes.add(v));
      break;
    }
    case booleans.length === 2: {
      variantTypes.add("boolean");
      break;
    }
  }
  const strings = types.filter(tsHelpers.isStringType);
  if (strings.length > 0) {
    const evaluated = match(strings).when((types2) => types2.every(tsHelpers.isTruthyStringType), F.constant("truthy string")).when((types2) => types2.every(tsHelpers.isFalsyStringType), F.constant("falsy string")).otherwise(F.constant("string"));
    variantTypes.add(evaluated);
  }
  const bigints = types.filter(tsHelpers.isBigIntType);
  if (bigints.length > 0) {
    const evaluated = match(bigints).when((types2) => types2.every(tsHelpers.isTruthyBigIntType), F.constant("truthy bigint")).when((types2) => types2.every(tsHelpers.isFalsyBigIntType), F.constant("falsy bigint")).otherwise(F.constant("bigint"));
    variantTypes.add(evaluated);
  }
  const numbers = types.filter(tsHelpers.isNumberType);
  if (numbers.length > 0) {
    const evaluated = match(numbers).when((types2) => types2.every(tsHelpers.isTruthyNumberType), F.constant("truthy number")).when((types2) => types2.every(tsHelpers.isFalsyNumberType), F.constant("falsy number")).otherwise(F.constant("number"));
    variantTypes.add(evaluated);
  }
  if (types.some(tsHelpers.isEnumType)) {
    variantTypes.add("enum");
  }
  if (types.some(tsHelpers.isObjectType)) {
    variantTypes.add("object");
  }
  if (types.some(tsHelpers.isAnyType)) {
    variantTypes.add("any");
  }
  if (types.some(tsHelpers.isNeverType)) {
    variantTypes.add("never");
  }
  return variantTypes;
}
function isInitExpression(node) {
  return node.type !== AST_NODE_TYPES.VariableDeclaration;
}
function getVariableInitExpression(at) {
  return (variable) => {
    return F.pipe(
      O.some(variable),
      O.flatMapNullable((v) => v.defs.at(at)),
      O.flatMap(
        (d) => "init" in d.node ? O.fromNullable(d.node.init) : O.none()
      ),
      O.filter(isInitExpression)
    );
  };
}
var no_leaked_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow problematic leaked values from being rendered"
    },
    messages: {
      noLeakedConditionalRendering: "Potential leaked value {{value}} that might cause unintentionally rendered values or rendering crashes."
    },
    schema: []
  },
  name: RULE_NAME24,
  create(context) {
    if (!context.sourceCode.text.includes("&&") && !context.sourceCode.text.includes("?")) return {};
    const services = ESLintUtils.getParserServices(context, false);
    function getReportDescriptor(node) {
      return match(node).when(AST11.isJSX, O.none).with({ type: AST_NODE_TYPES.LogicalExpression, operator: "&&" }, ({ left, right }) => {
        const isLeftUnaryNot = isMatching({ type: AST_NODE_TYPES.UnaryExpression, operator: "!" }, left);
        if (isLeftUnaryNot) return getReportDescriptor(right);
        const initialScope = context.sourceCode.getScope(left);
        const isLeftNan = isMatching({ type: AST_NODE_TYPES.Identifier, name: "NaN" }, left) || getStaticValue(left, initialScope)?.value === "NaN";
        if (isLeftNan) {
          return O.some({
            messageId: "noLeakedConditionalRendering",
            node: left,
            data: { value: context.sourceCode.getText(left) }
          });
        }
        const leftType = getConstrainedTypeAtLocation(services, left);
        const leftTypeVariants = inspectVariantTypes(unionTypeParts(leftType));
        const isLeftValid = Array.from(leftTypeVariants.values()).every((type) => allowedVariants.some((allowed) => allowed === type));
        if (isLeftValid) return getReportDescriptor(right);
        return O.some({
          messageId: "noLeakedConditionalRendering",
          node: left,
          data: { value: context.sourceCode.getText(left) }
        });
      }).with({ type: AST_NODE_TYPES.ConditionalExpression }, ({ alternate, consequent }) => {
        return O.orElse(getReportDescriptor(consequent), () => getReportDescriptor(alternate));
      }).with({ type: AST_NODE_TYPES.Identifier }, (n) => {
        return F.pipe(
          VAR.findVariable(n.name, context.sourceCode.getScope(n)),
          O.flatMap(getVariableInitExpression(0)),
          O.flatMap(getReportDescriptor)
        );
      }).otherwise(O.none);
    }
    const ruleFunction = F.flow(getReportDescriptor, O.map(context.report), F.constVoid);
    return {
      "JSXExpressionContainer > ConditionalExpression": ruleFunction,
      "JSXExpressionContainer > LogicalExpression": ruleFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME25 = "no-missing-component-display-name";
var no_missing_component_display_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'displayName' for 'memo' and 'forwardRef' components"
    },
    messages: {
      noMissingComponentDisplayName: "Add missing 'displayName' for component."
    },
    schema: []
  },
  name: RULE_NAME25,
  create(context) {
    if (!context.sourceCode.text.includes("memo") && !context.sourceCode.text.includes("forwardRef")) return {};
    const { ctx, listeners } = useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: node2, displayName, flag } of components.values()) {
          const isMemoOrForwardRef = Boolean(flag & ERFunctionComponentFlag.ForwardRef) || Boolean(flag & ERFunctionComponentFlag.Memo);
          if (O.isSome(AST11.getFunctionIdentifier(node2))) continue;
          if (!isMemoOrForwardRef) continue;
          if (O.isNone(displayName)) {
            context.report({
              messageId: "noMissingComponentDisplayName",
              node: node2
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME26 = "no-missing-key";
var no_missing_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'key' when rendering list"
    },
    messages: {
      noMissingKey: "Missing 'key' for element when rendering list.",
      noMissingKeyWithFragment: "Use fragment component instead of '<>' because it does not support `key`."
    },
    schema: []
  },
  name: RULE_NAME26,
  create(context) {
    const isWithinChildrenToArrayRef = MutRef.make(false);
    function checkIteratorElement(node) {
      switch (node.type) {
        case AST_NODE_TYPES.JSXElement: {
          const initialScope = context.sourceCode.getScope(node);
          if (!JSX7.hasProp(node.openingElement.attributes, "key", initialScope)) {
            return O.some({
              messageId: "noMissingKey",
              node
            });
          }
          return O.none();
        }
        case AST_NODE_TYPES.JSXFragment: {
          return O.some({
            messageId: "noMissingKeyWithFragment",
            node
          });
        }
        default:
          return O.none();
      }
    }
    function checkExpression(node) {
      switch (node.type) {
        case AST_NODE_TYPES.JSXElement:
        case AST_NODE_TYPES.JSXFragment:
          return checkIteratorElement(node);
        case AST_NODE_TYPES.ConditionalExpression:
          if (!("consequent" in node)) return O.none();
          return O.orElse(checkIteratorElement(node.consequent), () => checkIteratorElement(node.alternate));
        case AST_NODE_TYPES.LogicalExpression:
          if (!("left" in node)) return O.none();
          return O.orElse(checkIteratorElement(node.left), () => checkIteratorElement(node.right));
        default:
          return O.none();
      }
    }
    function checkBlockStatement(node) {
      return AST11.getNestedReturnStatements(node).reduce((acc, statement) => {
        if (!statement.argument) return acc;
        const maybeDescriptor = checkIteratorElement(statement.argument);
        if (O.isNone(maybeDescriptor)) return acc;
        const descriptor = maybeDescriptor.value;
        return [...acc, descriptor];
      }, []);
    }
    return {
      ArrayExpression(node) {
        if (MutRef.get(isWithinChildrenToArrayRef)) return;
        const elements = node.elements.filter(AST11.is(AST_NODE_TYPES.JSXElement));
        if (elements.length === 0) return;
        const initialScope = context.sourceCode.getScope(node);
        for (const element of elements) {
          if (!JSX7.hasProp(element.openingElement.attributes, "key", initialScope)) {
            context.report({
              messageId: "noMissingKey",
              node: element
            });
          }
        }
      },
      CallExpression(node) {
        if (isChildrenToArrayCall(node, context)) MutRef.set(isWithinChildrenToArrayRef, true);
        const isMapCall = AST11.isMapCallLoose(node);
        const isArrayFromCall = isMatching({
          type: AST_NODE_TYPES.CallExpression,
          callee: {
            type: AST_NODE_TYPES.MemberExpression,
            property: {
              name: "from"
            }
          }
        }, node);
        if (!isMapCall && !isArrayFromCall) return;
        if (MutRef.get(isWithinChildrenToArrayRef)) return;
        const fn = node.arguments[isMapCall ? 0 : 1];
        if (!AST11.isOneOf([AST_NODE_TYPES.ArrowFunctionExpression, AST_NODE_TYPES.FunctionExpression])(fn)) return;
        if (fn.body.type === AST_NODE_TYPES.BlockStatement) {
          for (const descriptor of checkBlockStatement(fn.body)) {
            context.report(descriptor);
          }
          return;
        }
        O.map(checkExpression(fn.body), context.report);
      },
      "CallExpression:exit"(node) {
        if (isChildrenToArrayCall(node, context)) MutRef.set(isWithinChildrenToArrayRef, false);
      },
      JSXFragment(node) {
        if (MutRef.get(isWithinChildrenToArrayRef)) return;
        if (node.parent.type === AST_NODE_TYPES.ArrayExpression) {
          context.report({
            messageId: "noMissingKeyWithFragment",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME27 = "no-nested-components";
var no_nested_components_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using unstable nested components"
    },
    messages: {
      nestedComponent: "Do not nest components inside other components. Move it to the top level.",
      nestedComponentInProps: "Do not nest components inside props. Move it to the top level or pass it as a prop."
    },
    schema: []
  },
  name: RULE_NAME27,
  create(context) {
    const hint = ERComponentHint.SkipMapCallback | ERComponentHint.SkipNullLiteral | ERComponentHint.SkipUndefinedLiteral | ERComponentHint.SkipBooleanLiteral | ERComponentHint.SkipStringLiteral | ERComponentHint.SkipNumberLiteral | ERComponentHint.StrictLogical | ERComponentHint.StrictConditional;
    const collector = useComponentCollector(context, hint);
    const collectorLegacy = useComponentCollectorLegacy();
    return {
      ...collector.listeners,
      ...collectorLegacy.listeners,
      "Program:exit"(node) {
        const functionComponents = Array.from(collector.ctx.getAllComponents(node).values());
        const classComponents = Array.from(collectorLegacy.ctx.getAllComponents(node).values());
        const isFunctionComponent = (node2) => {
          return AST11.isFunction(node2) && functionComponents.some((component) => component.node === node2);
        };
        const isClassComponent11 = (node2) => {
          return AST11.isClass(node2) && classComponents.some((component) => component.node === node2);
        };
        for (const { name: componentName, node: component } of functionComponents) {
          if (isDirectValueOfRenderPropertyLoose(component)) continue;
          if (O.isNone(componentName)) continue;
          const name2 = componentName.value;
          const isInsideProperty = component.parent.type === AST_NODE_TYPES.Property;
          const isInsideJSXPropValue = component.parent.type === AST_NODE_TYPES.JSXAttribute || O.isSome(JSX7.traverseUpProp(node, (n) => n.value?.type === AST_NODE_TYPES.JSXExpressionContainer));
          if (isInsideJSXPropValue) {
            if (!isDeclaredInRenderPropLoose(component)) {
              context.report({
                messageId: "nestedComponentInProps",
                node: component,
                data: {
                  name: name2
                }
              });
            }
            continue;
          }
          if (isInsideCreateElementProps(component, context)) {
            context.report({
              messageId: "nestedComponentInProps",
              node: component,
              data: {
                name: name2
              }
            });
            continue;
          }
          const maybeParentComponent = AST11.traverseUpGuard(component, isFunctionComponent);
          if (O.isSome(maybeParentComponent) && !isDirectValueOfRenderPropertyLoose(maybeParentComponent.value)) {
            context.report({
              messageId: isInsideProperty ? "nestedComponentInProps" : "nestedComponent",
              node: component,
              data: {
                name: name2
              }
            });
            continue;
          }
          const isInsideClassComponentRenderMethod = isInsideRenderMethod(component);
          if (isInsideClassComponentRenderMethod) {
            context.report({
              messageId: "nestedComponent",
              node: component,
              data: {
                name: name2
              }
            });
          }
        }
        for (const { name: name2, node: component } of classComponents) {
          if (O.isNone(AST11.traverseUp(component, (node2) => isClassComponent11(node2) || isFunctionComponent(node2)))) {
            continue;
          }
          context.report({
            messageId: "nestedComponent",
            node: component,
            data: {
              name: O.getOrElse(() => "unknown")(name2)
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME28 = "no-prop-types";
var no_prop_types_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'propTypes' property in components"
    },
    messages: {
      noPropTypes: "[Deprecated] Use TypeScript or another type-checking solution instead."
    },
    schema: []
  },
  name: RULE_NAME28,
  create(context) {
    if (!context.sourceCode.text.includes("propTypes")) return {};
    return {
      AssignmentExpression(node) {
        if (node.operator !== "=" || node.left.type !== AST_NODE_TYPES.MemberExpression) return;
        const { object, property } = node.left;
        if (object.type !== AST_NODE_TYPES.Identifier) return;
        if (property.type !== AST_NODE_TYPES.Identifier || property.name !== "propTypes") return;
        if (!isComponentName(object.name)) return;
        const isComponent = F.pipe(
          VAR.findVariable(object.name, context.sourceCode.getScope(node)),
          O.flatMap(VAR.getVariableNode(0)),
          O.exists((n) => AST11.isFunction(n) || isClassComponent(n))
        );
        if (!isComponent) return;
        context.report({ messageId: "noPropTypes", node: property });
      },
      PropertyDefinition(node) {
        if (!isClassComponent(node.parent.parent)) return;
        if (!node.static || node.key.type !== AST_NODE_TYPES.Identifier || node.key.name !== "propTypes") return;
        context.report({ messageId: "noPropTypes", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME29 = "no-redundant-should-component-update";
function isShouldComponentUpdate(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
var no_redundant_should_component_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'shouldComponentUpdate' in class component extends 'React.PureComponent'"
    },
    messages: {
      noRedundantShouldComponentUpdate: "'{{componentName}}' does not need 'shouldComponentUpdate' when extending 'React.PureComponent'."
    },
    schema: []
  },
  name: RULE_NAME29,
  create(context) {
    if (!context.sourceCode.text.includes("shouldComponentUpdate")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { name: name2, node: component, flag } of components.values()) {
          if (!(flag & ERClassComponentFlag.PureComponent)) continue;
          const { body } = component.body;
          for (const member of body) {
            if (isShouldComponentUpdate(member)) {
              context.report({
                messageId: "noRedundantShouldComponentUpdate",
                node: member,
                data: {
                  componentName: O.getOrElse(() => "PureComponent")(name2)
                }
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME30 = "no-set-state-in-component-did-mount";
function isComponentDidMount(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
var no_set_state_in_component_did_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentDidMount'"
    },
    messages: {
      noSetStateInComponentDidMount: "Do not call `this.setState` in `componentDidMount` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME30,
  create(context) {
    if (!context.sourceCode.text.includes("componentDidMount")) return {};
    function getReportDescriptor(node) {
      if (!isThisSetState(node)) return O.none();
      const maybeParentClass = AST11.traverseUp(
        node,
        AST11.isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression])
      );
      if (O.isNone(maybeParentClass)) return O.none();
      const parentClass = maybeParentClass.value;
      if (!isClassComponent(parentClass)) return O.none();
      const maybeParentMethod = AST11.traverseUp(node, isComponentDidMount);
      if (O.isNone(maybeParentMethod)) return O.none();
      const parentMethod = maybeParentMethod.value;
      if (parentMethod.parent !== parentClass.body) return O.none();
      if (context.sourceCode.getScope(node).upper !== context.sourceCode.getScope(parentMethod)) return O.none();
      return O.some({
        messageId: "noSetStateInComponentDidMount",
        node
      });
    }
    return {
      CallExpression: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME31 = "no-set-state-in-component-did-update";
function isComponentDidUpdate(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentDidUpdate";
}
var no_set_state_in_component_did_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentDidUpdate'"
    },
    messages: {
      noSetStateInComponentDidUpdate: "Do not call `this.setState` in `componentDidUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME31,
  create(context) {
    if (!context.sourceCode.text.includes("componentDidUpdate")) return {};
    function getReportDescriptor(node) {
      if (!isThisSetState(node)) return O.none();
      const maybeParentClass = AST11.traverseUp(
        node,
        AST11.isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression])
      );
      if (O.isNone(maybeParentClass)) return O.none();
      const parentClass = maybeParentClass.value;
      if (!isClassComponent(parentClass)) return O.none();
      const maybeParentMethod = AST11.traverseUp(node, isComponentDidUpdate);
      if (O.isNone(maybeParentMethod)) return O.none();
      const parentMethod = maybeParentMethod.value;
      if (parentMethod.parent !== parentClass.body) return O.none();
      if (context.sourceCode.getScope(node).upper !== context.sourceCode.getScope(parentMethod)) return O.none();
      return O.some({
        messageId: "noSetStateInComponentDidUpdate",
        node
      });
    }
    return {
      CallExpression: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME32 = "no-set-state-in-component-will-update";
function isComponentWillUpdate3(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
var no_set_state_in_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentWillUpdate'"
    },
    messages: {
      noSetStateInComponentWillUpdate: "Do not call `this.setState` in `componentWillUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME32,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillUpdate")) return {};
    function getReportDescriptor(node) {
      if (!isThisSetState(node)) return O.none();
      const maybeParentClass = AST11.traverseUp(
        node,
        AST11.isOneOf([AST_NODE_TYPES.ClassDeclaration, AST_NODE_TYPES.ClassExpression])
      );
      if (O.isNone(maybeParentClass)) return O.none();
      const parentClass = maybeParentClass.value;
      if (!isClassComponent(parentClass)) return O.none();
      const maybeParentMethod = AST11.traverseUp(node, isComponentWillUpdate3);
      if (O.isNone(maybeParentMethod)) return O.none();
      const parentMethod = maybeParentMethod.value;
      if (parentMethod.parent !== parentClass.body) return O.none();
      if (context.sourceCode.getScope(node).upper !== context.sourceCode.getScope(parentMethod)) return O.none();
      return O.some({
        messageId: "noSetStateInComponentWillUpdate",
        node
      });
    }
    return {
      CallExpression: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME33 = "no-string-refs";
function containsStringLiteral({ value }) {
  return value?.type === AST_NODE_TYPES.Literal && isString(value.value);
}
function containsStringExpressionContainer({ value }) {
  if (value?.type !== AST_NODE_TYPES.JSXExpressionContainer) return false;
  if (value.expression.type === AST_NODE_TYPES.Literal) return isString(value.expression.value);
  return value.expression.type === AST_NODE_TYPES.TemplateLiteral;
}
var no_string_refs_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using deprecated string refs"
    },
    messages: {
      noStringRefs: "[Deprecated] Use callback refs instead."
    },
    schema: []
  },
  name: RULE_NAME33,
  create(context) {
    return {
      JSXAttribute(node) {
        if (node.name.name !== "ref") return;
        if (containsStringLiteral(node) || containsStringExpressionContainer(node)) {
          context.report({
            messageId: "noStringRefs",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME34 = "no-unsafe-component-will-mount";
function isUnsafeComponentWillMount(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
var no_unsafe_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillMount'"
    },
    messages: {
      noUnsafeComponentWillMount: "Do not use 'UNSAFE_componentWillMount'."
    },
    schema: []
  },
  name: RULE_NAME34,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillMount")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillMount(member)) {
              context.report({
                messageId: "noUnsafeComponentWillMount",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME35 = "no-unsafe-component-will-receive-props";
function isUnsafeComponentWillReceiveProps(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
var no_unsafe_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillReceiveProps'"
    },
    messages: {
      noUnsafeComponentWillReceiveProps: "Do not use 'UNSAFE_componentWillReceiveProps'."
    },
    schema: []
  },
  name: RULE_NAME35,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillReceiveProps")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillReceiveProps(member)) {
              context.report({
                messageId: "noUnsafeComponentWillReceiveProps",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME36 = "no-unsafe-component-will-update";
function isUnsafeComponentWillUpdate(node) {
  return AST11.isOneOf([AST_NODE_TYPES.MethodDefinition, AST_NODE_TYPES.PropertyDefinition])(node) && node.key.type === AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
var no_unsafe_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillUpdate'"
    },
    messages: {
      noUnsafeComponentWillUpdate: "Do not use 'UNSAFE_componentWillUpdate'."
    },
    schema: []
  },
  name: RULE_NAME36,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillUpdate")) return {};
    const { ctx, listeners } = useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillUpdate(member)) {
              context.report({
                messageId: "noUnsafeComponentWillUpdate",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME37 = "no-unstable-context-value";
var no_unstable_context_value_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing constructed values to context providers"
    },
    messages: {
      noUnstableContextValue: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render.",
      noUnstableContextValueWithFunction: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. Consider wrapping it in a useCallback hook.",
      noUnstableContextValueWithIdentifier: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. Consider wrapping it in a useMemo hook."
    },
    schema: []
  },
  name: RULE_NAME37,
  create(context) {
    const { ctx, listeners } = useComponentCollector(context);
    const possibleValueConstructions = /* @__PURE__ */ new Map();
    return {
      ...listeners,
      JSXOpeningElement(node) {
        const openingElementName = node.name;
        if (openingElementName.type !== AST_NODE_TYPES.JSXMemberExpression) return;
        if (openingElementName.property.name !== "Provider") return;
        const maybeJSXValueAttribute = O.fromNullable(
          node.attributes.find((attribute) => {
            return attribute.type === AST_NODE_TYPES.JSXAttribute && attribute.name.name === "value";
          })
        );
        if (O.isNone(maybeJSXValueAttribute) || !("value" in maybeJSXValueAttribute.value)) return;
        const valueNode = maybeJSXValueAttribute.value.value;
        if (valueNode?.type !== AST_NODE_TYPES.JSXExpressionContainer) return;
        const valueExpression = valueNode.expression;
        const initialScope = context.sourceCode.getScope(valueExpression);
        const construction = VAR.inspectConstruction(valueExpression, initialScope);
        if (construction._tag === "None") return;
        O.map(
          ctx.getCurrentFunction(),
          ([_, currentFn]) => possibleValueConstructions.set(currentFn, [
            ...possibleValueConstructions.get(currentFn) ?? [],
            construction
          ])
        );
      },
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node).values();
        for (const { node: component } of components) {
          const constructions = possibleValueConstructions.get(component);
          if (!constructions) continue;
          for (const construction of constructions) {
            if (construction._tag === "None") continue;
            const { node: constructionNode, _tag } = construction;
            const messageId = _tag.startsWith("Function") ? "noUnstableContextValueWithFunction" : "noUnstableContextValueWithIdentifier";
            context.report({
              messageId,
              node: constructionNode,
              data: {
                type: AST11.toReadableNodeType(constructionNode)
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME38 = "no-unstable-default-props";
var no_unstable_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using unstable value as default param in function component"
    },
    messages: {
      noUnstableDefaultProps: "A/an '{{forbiddenType}}' as default prop. This could lead to potential infinite render loop in React. Use a variable instead of '{{forbiddenType}}'."
    },
    schema: []
  },
  name: RULE_NAME38,
  create(context) {
    const { ctx, listeners } = useComponentCollector(context);
    const possibleDestructuringDeclarators = /* @__PURE__ */ new WeakMap();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { params } = component;
          const [props] = params;
          if (!props) continue;
          const properties = match(props).with({ type: AST_NODE_TYPES.ObjectPattern }, ({ properties: properties2 }) => properties2).with({ type: AST_NODE_TYPES.Identifier }, ({ name: name2 }) => {
            const variableDeclarators = possibleDestructuringDeclarators.get(component);
            if (!variableDeclarators) return [];
            const declarators = variableDeclarators.filter((d) => d.init.name === name2);
            return declarators.flatMap((d) => d.id.properties);
          }).otherwise(() => []);
          for (const prop of properties) {
            if (prop.type !== AST_NODE_TYPES.Property || prop.value.type !== AST_NODE_TYPES.AssignmentPattern) continue;
            const { value } = prop;
            const { right } = value;
            const initialScope = context.sourceCode.getScope(value);
            const construction = VAR.inspectConstruction(
              value,
              initialScope,
              VAR.ConstructionHint.StrictCallExpression
            );
            if (construction._tag === "None") continue;
            const forbiddenType = AST11.toReadableNodeType(right);
            context.report({
              messageId: "noUnstableDefaultProps",
              node: right,
              data: {
                forbiddenType
              }
            });
          }
        }
      },
      "VariableDeclarator[id.type='ObjectPattern'][init.type='Identifier']"(node) {
        O.map(
          ctx.getCurrentFunction(),
          ([_, currentFn]) => possibleDestructuringDeclarators.set(currentFn, [
            ...possibleDestructuringDeclarators.get(currentFn) ?? [],
            node
          ])
        );
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME39 = "no-unused-class-component-members";
var LIFECYCLE_METHODS = /* @__PURE__ */ new Set([
  "componentDidCatch",
  "componentDidMount",
  "componentDidUpdate",
  "componentWillMount",
  "componentWillReceiveProps",
  "componentWillUnmount",
  "componentWillUpdate",
  "constructor",
  "getSnapshotBeforeUpdate",
  "render",
  "shouldComponentUpdate",
  "state",
  "UNSAFE_componentWillMount",
  "UNSAFE_componentWillReceiveProps",
  "UNSAFE_componentWillUpdate"
]);
function getName3(node) {
  if (node.type === AST_NODE_TYPES.TSAsExpression) {
    return getName3(node.expression);
  }
  if (node.type === AST_NODE_TYPES.Identifier || node.type === AST_NODE_TYPES.PrivateIdentifier) {
    return O.some(node.name);
  }
  if (node.type === AST_NODE_TYPES.Literal) {
    return O.some(String(node.value));
  }
  if (node.type === AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return O.fromNullable(node.quasis[0]?.value.raw);
  }
  return O.none();
}
var no_unused_class_component_members_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused class component members"
    },
    messages: {
      noUnusedClassComponentMembers: "Unused method or property '{{methodName}}'' of class '{{className}}'."
    },
    schema: []
  },
  name: RULE_NAME39,
  create(context) {
    const classStack = [];
    const methodStack = [];
    const propertyDefs = /* @__PURE__ */ new WeakMap();
    const propertyUsages = /* @__PURE__ */ new WeakMap();
    function classEnter(node) {
      classStack.push(node);
      if (!isClassComponent(node)) return;
      propertyDefs.set(node, /* @__PURE__ */ new Set());
      propertyUsages.set(node, /* @__PURE__ */ new Set());
    }
    function classExit() {
      const currentClass = classStack.pop();
      if (!currentClass || !isClassComponent(currentClass)) return;
      const className = O.map(AST11.getClassIdentifier(currentClass), (id) => id.name);
      const defs = propertyDefs.get(currentClass);
      const usages = propertyUsages.get(currentClass);
      if (!defs) return;
      for (const def of defs) {
        const name2 = getName3(def);
        if (O.isNone(name2)) continue;
        if (usages?.has(name2.value) || LIFECYCLE_METHODS.has(name2.value)) continue;
        context.report({
          messageId: "noUnusedClassComponentMembers",
          node: def,
          data: {
            className: O.getOrElse(className, () => "Component"),
            methodName: name2.value
          }
        });
      }
    }
    function methodEnter(node) {
      methodStack.push(node);
      const currentClass = classStack.at(-1);
      if (!currentClass || !isClassComponent(currentClass)) return;
      if (node.static) return;
      if (AST11.isKeyLiteralLike(node, node.key)) {
        propertyDefs.get(currentClass)?.add(node.key);
      }
    }
    function methodExit() {
      methodStack.pop();
    }
    return {
      ClassDeclaration: classEnter,
      "ClassDeclaration:exit": classExit,
      ClassExpression: classEnter,
      "ClassExpression:exit": classExit,
      MemberExpression(node) {
        const currentClass = classStack.at(-1);
        const currentMethod = methodStack.at(-1);
        if (!currentClass || !currentMethod) return;
        if (!isClassComponent(currentClass) || currentMethod.static) return;
        if (!AST11.isThisExpression(node.object) || !AST11.isKeyLiteralLike(node, node.property)) return;
        if (node.parent.type === AST_NODE_TYPES.AssignmentExpression && node.parent.left === node) {
          propertyDefs.get(currentClass)?.add(node.property);
          return;
        }
        O.map(getName3(node.property), (name2) => propertyUsages.get(currentClass)?.add(name2));
      },
      MethodDefinition: methodEnter,
      "MethodDefinition:exit": methodExit,
      PropertyDefinition: methodEnter,
      "PropertyDefinition:exit": methodExit,
      VariableDeclarator(node) {
        const currentClass = classStack.at(-1);
        const currentMethod = methodStack.at(-1);
        if (!currentClass || !currentMethod) return;
        if (!isClassComponent(currentClass) || currentMethod.static) return;
        if (node.init && AST11.isThisExpression(node.init) && node.id.type === AST_NODE_TYPES.ObjectPattern) {
          for (const prop of node.id.properties) {
            if (prop.type === AST_NODE_TYPES.Property && AST11.isKeyLiteralLike(prop, prop.key)) {
              O.map(getName3(prop.key), (name2) => propertyUsages.get(currentClass)?.add(name2));
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME40 = "no-unused-state";
function getName4(node) {
  if (node.type === AST_NODE_TYPES.TSAsExpression) {
    return getName4(node.expression);
  }
  if (node.type === AST_NODE_TYPES.Identifier || node.type === AST_NODE_TYPES.PrivateIdentifier) {
    return O.some(node.name);
  }
  if (node.type === AST_NODE_TYPES.Literal) {
    return O.some(String(node.value));
  }
  if (node.type === AST_NODE_TYPES.TemplateLiteral && node.expressions.length === 0) {
    return O.fromNullable(node.quasis[0]?.value.raw);
  }
  return O.none();
}
function isAssignmentToThisState2(node) {
  const { left } = node;
  return left.type === AST_NODE_TYPES.MemberExpression && AST11.isThisExpression(left.object) && O.exists(getName4(left.property), (name2) => name2 === "state");
}
var isGetDerivedStateFromProps = isMatching({
  key: {
    name: "getDerivedStateFromProps"
  },
  static: true,
  value: {
    params: P.array()
  }
});
var no_unused_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused state of class component"
    },
    messages: {
      noUnusedState: "Unused class component state in '{{className}}'"
    },
    schema: []
  },
  name: RULE_NAME40,
  create(context) {
    const classStack = [];
    const methodStack = [];
    const constructorStack = [];
    const stateDefs = /* @__PURE__ */ new WeakMap();
    function classEnter(node) {
      classStack.push(node);
    }
    function classExit() {
      const currentClass = classStack.pop();
      if (!currentClass || !isClassComponent(currentClass)) return;
      const className = O.map(AST11.getClassIdentifier(currentClass), (id) => id.name);
      const [def, isUsed] = stateDefs.get(currentClass) ?? [O.none(), false];
      if (O.isNone(def) || isUsed) return;
      context.report({
        messageId: "noUnusedState",
        node: def.value,
        data: {
          className: O.getOrElse(className, () => "Component")
        }
      });
    }
    function methodEnter(node) {
      methodStack.push(node);
      const currentClass = classStack.at(-1);
      if (!currentClass || !isClassComponent(currentClass)) return;
      if (node.static) {
        if (isGetDerivedStateFromProps(node) && node.value.params.length > 1) {
          const [def] = stateDefs.get(currentClass) ?? [O.none()];
          stateDefs.set(currentClass, [def, true]);
        }
        return;
      }
      if (O.exists(getName4(node.key), (name2) => name2 === "state")) {
        stateDefs.set(currentClass, [O.some(node.key), false]);
      }
    }
    function methodExit() {
      methodStack.pop();
    }
    function constructorEnter(node) {
      constructorStack.push(node);
    }
    function constructorExit() {
      constructorStack.pop();
    }
    return {
      AssignmentExpression(node) {
        if (!isAssignmentToThisState2(node)) return;
        const currentClass = classStack.at(-1);
        if (!currentClass || !isClassComponent(currentClass)) return;
        const currentConstructor = constructorStack.at(-1);
        if (!currentConstructor || !currentClass.body.body.includes(currentConstructor)) return;
        const [_, isUsed] = stateDefs.get(currentClass) ?? [O.none(), false];
        stateDefs.set(currentClass, [O.some(node.left), isUsed]);
      },
      ClassDeclaration: classEnter,
      "ClassDeclaration:exit": classExit,
      ClassExpression: classEnter,
      "ClassExpression:exit": classExit,
      MemberExpression(node) {
        if (!AST11.isThisExpression(node.object)) return;
        if (!O.exists(getName4(node.property), (name2) => name2 === "state")) return;
        const currentClass = classStack.at(-1);
        if (!currentClass || !isClassComponent(currentClass)) return;
        const currentMethod = methodStack.at(-1);
        if (!currentMethod || currentMethod.static) return;
        if (currentMethod === constructorStack.at(-1)) return;
        if (!currentClass.body.body.includes(currentMethod)) return;
        const [def] = stateDefs.get(currentClass) ?? [O.none(), false];
        stateDefs.set(currentClass, [def, true]);
      },
      MethodDefinition: methodEnter,
      "MethodDefinition:exit": methodExit,
      "MethodDefinition[key.name='constructor']": constructorEnter,
      "MethodDefinition[key.name='constructor']:exit": constructorExit,
      PropertyDefinition: methodEnter,
      "PropertyDefinition:exit": methodExit,
      VariableDeclarator(node) {
        const currentClass = classStack.at(-1);
        if (!currentClass || !isClassComponent(currentClass)) return;
        const currentMethod = methodStack.at(-1);
        if (!currentMethod || currentMethod.static) return;
        if (currentMethod === constructorStack.at(-1)) return;
        if (!currentClass.body.body.includes(currentMethod)) return;
        if (!(node.init && AST11.isThisExpression(node.init) && node.id.type === AST_NODE_TYPES.ObjectPattern)) return;
        const hasState = node.id.properties.some((prop) => {
          if (prop.type === AST_NODE_TYPES.Property && AST11.isKeyLiteralLike(prop, prop.key)) {
            return O.exists(getName4(prop.key), (name2) => name2 === "state");
          }
          return false;
        });
        if (!hasState) return;
        const [def] = stateDefs.get(currentClass) ?? [O.none(), false];
        stateDefs.set(currentClass, [def, true]);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME41 = "no-useless-fragment";
function check(node, context) {
  const initialScope = context.sourceCode.getScope(node);
  if (JSX7.isKeyedElement(node, initialScope)) return;
  if (JSX7.isBuiltInElement(node.parent)) context.report({ messageId: "noUselessFragmentInBuiltIn", node });
  if (node.children.length === 0) return context.report({ messageId: "noUselessFragment", node });
  const isChildren = AST11.isOneOf([AST_NODE_TYPES.JSXElement, AST_NODE_TYPES.JSXFragment])(node.parent);
  const [firstChildren] = node.children;
  if (node.children.length === 1 && JSX7.isLiteral(firstChildren) && !isChildren) return;
  const nonPaddingChildren = node.children.filter((child) => !JSX7.isPaddingSpaces(child));
  if (nonPaddingChildren.length > 1) return;
  if (nonPaddingChildren.length === 0) return context.report({ messageId: "noUselessFragment", node });
  const [first] = nonPaddingChildren;
  if (isMatching({ type: AST_NODE_TYPES.JSXExpressionContainer, expression: P.not(AST_NODE_TYPES.CallExpression) }, first)) return;
  context.report({ messageId: "noUselessFragment", node });
}
var no_useless_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unnecessary fragments"
    },
    messages: {
      noUselessFragment: "A fragment contains less than two children is unnecessary.",
      noUselessFragmentInBuiltIn: "A fragment placed inside a built-in component is unnecessary."
    },
    schema: []
  },
  name: RULE_NAME41,
  create(context) {
    return {
      JSXElement(node) {
        if (!isFragmentElement(node, context)) return;
        check(node, context);
      },
      JSXFragment(node) {
        check(node, context);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME42 = "prefer-destructuring-assignment";
function isMemberExpressionWithObjectName(node) {
  return node.object.type === AST_NODE_TYPES.Identifier && "name" in node.object;
}
var prefer_destructuring_assignment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using destructuring assignment in component props and context"
    },
    messages: {
      preferDestructuringAssignment: "Use destructuring assignment for {{name}}."
    },
    schema: []
  },
  name: RULE_NAME42,
  create(context) {
    const { ctx, listeners } = useComponentCollector(context);
    const memberExpressionWithNames = [];
    return {
      ...listeners,
      MemberExpression(node) {
        if (isMemberExpressionWithObjectName(node)) {
          const scope = context.sourceCode.getScope(node);
          memberExpressionWithNames.push([scope, node]);
        }
      },
      "Program:exit"(node) {
        const components = Array.from(ctx.getAllComponents(node).values());
        function isFunctionComponent(block) {
          if (!AST11.isFunction(block)) return false;
          const maybeId = AST11.getFunctionIdentifier(block);
          return O.isSome(maybeId) && isComponentName(maybeId.value.name) && components.some((component) => component.node === block);
        }
        for (const [initialScope, memberExpression] of memberExpressionWithNames) {
          let scope = initialScope;
          let isComponent = isFunctionComponent(scope.block);
          while (!isComponent && scope.upper && scope.upper !== scope) {
            scope = scope.upper;
            isComponent = isFunctionComponent(scope.block);
          }
          if (!isComponent) continue;
          const component = scope.block;
          if (!("params" in component)) continue;
          const [props, ctx2] = component.params;
          const isMatch = isMatching({ name: memberExpression.object.name });
          if (isMatch(props)) {
            context.report({
              messageId: "preferDestructuringAssignment",
              node: memberExpression,
              data: {
                name: "props"
              }
            });
          }
          if (isMatch(ctx2)) {
            context.report({
              messageId: "preferDestructuringAssignment",
              node: memberExpression,
              data: {
                name: "context"
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME43 = "prefer-read-only-props";
function isReadonlyType(type, services) {
  try {
    const im = getTypeImmutability(services.program, type);
    return isUnknown(im) || isImmutable(im) || isReadonlyShallow(im) || isReadonlyDeep(im);
  } catch {
    return true;
  }
}
var prefer_read_only_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce read-only props in components"
    },
    messages: {
      preferReadOnlyProps: "A function component's props should be read-only."
    },
    schema: []
  },
  name: RULE_NAME43,
  create(context) {
    const services = ESLintUtils.getParserServices(context, false);
    const { ctx, listeners } = useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const [_, component] of components) {
          const [props] = component.node.params;
          if (!props) continue;
          const propsType = getConstrainedTypeAtLocation(services, props);
          if (isTypeReadonly(services.program, propsType) || isReadonlyType(propsType, services)) continue;
          context.report({ messageId: "preferReadOnlyProps", node: props });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME44 = "prefer-shorthand-boolean";
var prefer_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using shorthand boolean attributes"
    },
    messages: {
      preferShorthandBoolean: "Use shorthand boolean attribute '{{propName}}'."
    },
    schema: []
  },
  name: RULE_NAME44,
  create(context) {
    function getReportDescriptor(node) {
      const { value } = node;
      const propName = JSX7.getPropName(node);
      const hasValueTrue = value?.type === AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === AST_NODE_TYPES.Literal && value.expression.value === true;
      if (!hasValueTrue) return O.none();
      return O.some({
        messageId: "preferShorthandBoolean",
        node,
        data: {
          propName
        }
      });
    }
    return {
      JSXAttribute: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});
var RULE_NAME45 = "prefer-shorthand-fragment";
var prefer_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using fragment syntax instead of 'Fragment' component"
    },
    messages: {
      preferShorthandFragment: "Use fragment shorthand syntax instead of 'Fragment' component."
    },
    schema: []
  },
  name: RULE_NAME45,
  create(context) {
    function getReportDescriptor(node) {
      if (!isFragmentElement(node, context)) return O.none();
      const hasAttributes = node.openingElement.attributes.length > 0;
      if (hasAttributes) return O.none();
      return O.some({
        messageId: "preferShorthandFragment",
        node
      });
    }
    return {
      JSXElement: F.flow(getReportDescriptor, O.map(context.report))
    };
  },
  defaultOptions: []
});

// src/index.ts
var DEFAULT_ESLINT_REACT_SETTINGS = {
  additionalHooks: {
    useLayoutEffect: ["useIsomorphicLayoutEffect"]
  },
  polymorphicPropName: "as",
  skipImportCheck: false,
  version: "detect"
};
var src_default = {
  meta: {
    name,
    version
  },
  rules: {
    "avoid-shorthand-boolean": avoid_shorthand_boolean_default,
    "avoid-shorthand-fragment": avoid_shorthand_fragment_default,
    "ensure-forward-ref-using-ref": ensure_forward_ref_using_ref_default,
    "no-access-state-in-setstate": no_access_state_in_setstate_default,
    "no-array-index-key": no_array_index_key_default,
    "no-children-count": no_children_count_default,
    "no-children-for-each": no_children_for_each_default,
    "no-children-map": no_children_map_default,
    "no-children-only": no_children_only_default,
    "no-children-prop": no_children_prop_default,
    "no-children-to-array": no_children_to_array_default,
    "no-class-component": no_class_component_default,
    "no-clone-element": no_clone_element_default,
    "no-comment-textnodes": no_comment_textnodes_default,
    "no-complex-conditional-rendering": no_complex_conditional_rendering_default,
    "no-component-will-mount": no_component_will_mount_default,
    "no-component-will-receive-props": no_component_will_receive_props_default,
    "no-component-will-update": no_component_will_update_default,
    "no-create-ref": no_create_ref_default,
    "no-default-props": no_default_props_default,
    "no-direct-mutation-state": no_direct_mutation_state_default,
    "no-duplicate-key": no_duplicate_key_default,
    "no-implicit-key": no_implicit_key_default,
    "no-leaked-conditional-rendering": no_leaked_conditional_rendering_default,
    "no-missing-component-display-name": no_missing_component_display_name_default,
    "no-missing-key": no_missing_key_default,
    "no-nested-components": no_nested_components_default,
    "no-prop-types": no_prop_types_default,
    "no-redundant-should-component-update": no_redundant_should_component_update_default,
    "no-set-state-in-component-did-mount": no_set_state_in_component_did_mount_default,
    "no-set-state-in-component-did-update": no_set_state_in_component_did_update_default,
    "no-set-state-in-component-will-update": no_set_state_in_component_will_update_default,
    "no-string-refs": no_string_refs_default,
    "no-unsafe-component-will-mount": no_unsafe_component_will_mount_default,
    "no-unsafe-component-will-receive-props": no_unsafe_component_will_receive_props_default,
    "no-unsafe-component-will-update": no_unsafe_component_will_update_default,
    "no-unstable-context-value": no_unstable_context_value_default,
    "no-unstable-default-props": no_unstable_default_props_default,
    "no-unused-class-component-members": no_unused_class_component_members_default,
    "no-unused-state": no_unused_state_default,
    "no-useless-fragment": no_useless_fragment_default,
    "prefer-destructuring-assignment": prefer_destructuring_assignment_default,
    "prefer-read-only-props": prefer_read_only_props_default,
    "prefer-shorthand-boolean": prefer_shorthand_boolean_default,
    "prefer-shorthand-fragment": prefer_shorthand_fragment_default,
    // Deprecated Rules
    /** @deprecated Use `no-complex-conditional-rendering` instead. */
    "no-complicated-conditional-rendering": no_complex_conditional_rendering_default
  },
  DEFAULT_ESLINT_REACT_SETTINGS
};

export { src_default as default };
