'use strict';

var AST = require('@eslint-react/ast');
var tools = require('@eslint-react/tools');
var scopeManager = require('@typescript-eslint/scope-manager');
var types = require('@typescript-eslint/types');
var tsPattern = require('ts-pattern');
var astUtils = require('@typescript-eslint/utils/ast-utils');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST__namespace = /*#__PURE__*/_interopNamespace(AST);

// src/construction.ts
var Construction = tools.Data.taggedEnum();
var ConstructionHint = {
  None: 0n,
  StrictCallExpression: 1n << 0n
};
function inspectConstruction(node, initialScope, hint = ConstructionHint.None) {
  const detect = (node2) => {
    return tsPattern.match(node2).when(AST__namespace.is(types.AST_NODE_TYPES.ArrayExpression), (node3) => Construction.Array({ node: node3, usage: tools.O.none() })).when(AST__namespace.is(types.AST_NODE_TYPES.ObjectExpression), (node3) => Construction.ObjectExpression({ node: node3, usage: tools.O.none() })).when(AST__namespace.is(types.AST_NODE_TYPES.ClassExpression), (node3) => Construction.ClassExpression({ node: node3, usage: tools.O.none() })).when(AST__namespace.is(types.AST_NODE_TYPES.JSXElement), (node3) => Construction.JSXElement({ node: node3, usage: tools.O.none() })).when(AST__namespace.is(types.AST_NODE_TYPES.JSXFragment), (node3) => Construction.JSXFragment({ node: node3, usage: tools.O.none() })).when(AST__namespace.is(types.AST_NODE_TYPES.CallExpression), (node3) => {
      if (hint & ConstructionHint.StrictCallExpression) {
        return Construction.CallExpression({ node: node3, usage: tools.O.none() });
      }
      return Construction.None();
    }).when(AST__namespace.is(types.AST_NODE_TYPES.NewExpression), (node3) => Construction.NewExpression({ node: node3, usage: tools.O.none() })).when(
      AST__namespace.isOneOf([
        types.AST_NODE_TYPES.FunctionExpression,
        types.AST_NODE_TYPES.ArrowFunctionExpression
      ]),
      (node3) => {
        return Construction.FunctionExpression({ node: node3, usage: tools.O.none() });
      }
    ).when(AST__namespace.is(types.AST_NODE_TYPES.MemberExpression), (node3) => {
      if (!("object" in node3)) return Construction.None();
      const object = detect(node3.object);
      if (object._tag === "None") return object;
      return {
        ...object,
        usage: tools.O.some(node3.object)
      };
    }).when(AST__namespace.is(types.AST_NODE_TYPES.AssignmentExpression), (node3) => {
      if (!("right" in node3)) return Construction.None();
      const right = detect(node3.right);
      if (right._tag === "None") return right;
      return Construction.AssignmentExpression({
        node: right.node,
        usage: tools.O.some(node3)
      });
    }).when(AST__namespace.is(types.AST_NODE_TYPES.AssignmentPattern), (node3) => {
      if (!("right" in node3)) return Construction.None();
      const right = detect(node3.right);
      if (right._tag === "None") return right;
      return Construction.AssignmentPattern({
        node: right.node,
        usage: tools.O.some(node3)
      });
    }).when(AST__namespace.is(types.AST_NODE_TYPES.LogicalExpression), (node3) => {
      if (!("left" in node3 && "right" in node3)) return Construction.None();
      const left = detect(node3.left);
      if (left._tag !== "None") return left;
      return detect(node3.right);
    }).when(AST__namespace.is(types.AST_NODE_TYPES.ConditionalExpression), (node3) => {
      if (!("consequent" in node3 && "alternate" in node3 && !tools.isNullable(node3.alternate))) {
        return Construction.None();
      }
      const consequent = detect(node3.consequent);
      if (consequent._tag !== "None") return Construction.None();
      return detect(node3.alternate);
    }).when(AST__namespace.is(types.AST_NODE_TYPES.Identifier), (node3) => {
      if (!("name" in node3 && tools.isString(node3.name))) return Construction.None();
      const maybeLatestDef = tools.O.fromNullable(initialScope.set.get(node3.name)?.defs.at(-1));
      if (tools.O.isNone(maybeLatestDef)) return Construction.None();
      const latestDef = maybeLatestDef.value;
      if (latestDef.type !== scopeManager.DefinitionType.Variable && latestDef.type !== scopeManager.DefinitionType.FunctionName) {
        return Construction.None();
      }
      if (latestDef.node.type === types.AST_NODE_TYPES.FunctionDeclaration) {
        return Construction.FunctionDeclaration({
          node: latestDef.node,
          usage: tools.O.some(node3)
        });
      }
      if (!("init" in latestDef.node) || latestDef.node.init === null) {
        return Construction.None();
      }
      return detect(latestDef.node.init);
    }).when(AST__namespace.is(types.AST_NODE_TYPES.Literal), (node3) => {
      if ("regex" in node3) {
        return Construction.RegExpLiteral({ node: node3, usage: tools.O.none() });
      }
      return Construction.None();
    }).when(
      AST__namespace.isOneOf([
        types.AST_NODE_TYPES.TSAsExpression,
        types.AST_NODE_TYPES.TSTypeAssertion
      ]),
      () => {
        if (!("expression" in node2) || !tools.isObject(node2.expression)) {
          return Construction.None();
        }
        return detect(node2.expression);
      }
    ).otherwise(() => Construction.None());
  };
  return detect(node);
}
var findVariable = tools.F.dual(2, (nameOrNode, initialScope) => {
  return tools.O.fromNullable(astUtils.findVariable(initialScope, nameOrNode));
});

// src/get-child-scopes.ts
function getChidScopes(scope, prev = []) {
  return [scope, ...scope.childScopes.reduce((acc, prev2) => getChidScopes(prev2, [...acc, prev2]), prev)];
}
function getScope(node, scopeManager) {
  const { type, parent } = node;
  const inner = type !== types.AST_NODE_TYPES.Program;
  const scope = scopeManager.acquire(node, inner);
  if (scope) return scope;
  if (parent) return getScope(parent, scopeManager);
  return null;
}
function getVariableDeclaratorID(node, prev) {
  switch (true) {
    case (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return tools.O.some(node.id);
    case (node.type === types.AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return tools.O.some(node.left);
    case (node.type === types.AST_NODE_TYPES.BlockStatement || node.type === types.AST_NODE_TYPES.Program || node.parent === node):
      return tools.O.none();
    default:
      return getVariableDeclaratorID(node.parent, node);
  }
}
function getVariableDef(at) {
  return (variable) => {
    return tools.O.fromNullable(variable.defs[at]);
  };
}
function getVariableNode(at) {
  return (variable) => {
    return tools.F.pipe(
      tools.O.some(variable),
      tools.O.flatMap(getVariableDef(at)),
      tools.O.flatMapNullable((def) => {
        switch (true) {
          case ("init" in def.node && def.node.init && !("declarations" in def.node.init)):
            return def.node.init;
          case (def.type === scopeManager.DefinitionType.FunctionName && def.node.type === types.AST_NODE_TYPES.FunctionDeclaration):
            return def.node;
          case (def.type === scopeManager.DefinitionType.ClassName && def.node.type === types.AST_NODE_TYPES.ClassDeclaration):
            return def.node;
          default:
            return null;
        }
      })
    );
  };
}
function getVariables(initialScope) {
  let scope = initialScope;
  const variables = [...scope.variables];
  while (scope.type !== scopeManager.ScopeType.global) {
    scope = scope.upper;
    variables.push(...scope.variables);
  }
  return variables.reverse();
}
var thisBlockTypes = [
  types.AST_NODE_TYPES.FunctionDeclaration,
  types.AST_NODE_TYPES.FunctionExpression,
  types.AST_NODE_TYPES.ClassBody,
  types.AST_NODE_TYPES.Program
];
function isNodeValueEqual(a, b, initialScopes) {
  if (a.type === types.AST_NODE_TYPES.Literal && b.type === types.AST_NODE_TYPES.Literal) return a.value === b.value;
  if (a.type === types.AST_NODE_TYPES.TemplateElement && b.type === types.AST_NODE_TYPES.TemplateElement) {
    return a.value.cooked === b.value.cooked;
  }
  const [aScope, bScope] = initialScopes;
  const aStatic = astUtils.getStaticValue(a, aScope);
  const bStatic = astUtils.getStaticValue(b, bScope);
  if (aStatic && bStatic) return aStatic.value === bStatic.value;
  if (a.type === types.AST_NODE_TYPES.Identifier && b.type === types.AST_NODE_TYPES.Identifier) {
    const va = findVariable(a, aScope);
    const vb = findVariable(b, bScope);
    const ia = tools.O.flatMap(va, getVariableNode(0));
    const ib = tools.O.flatMap(vb, getVariableNode(0));
    if (tools.O.isNone(ia) || tools.O.isNone(ib)) return false;
    return ia.value === ib.value;
  }
  if (a.type === types.AST_NODE_TYPES.MemberExpression && b.type === types.AST_NODE_TYPES.MemberExpression) {
    return AST__namespace.isNodeEqual(a.property, b.property) && isNodeValueEqual(a.object, b.object, initialScopes);
  }
  if (a.type === types.AST_NODE_TYPES.ThisExpression && b.type === types.AST_NODE_TYPES.ThisExpression) {
    if (aScope.block === bScope.block) return true;
    const fa = AST__namespace.traverseUp(a, AST__namespace.isOneOf(thisBlockTypes));
    const fb = AST__namespace.traverseUp(a, AST__namespace.isOneOf(thisBlockTypes));
    if (tools.O.isSome(fa) && tools.O.isSome(fb)) return fa.value === fb.value;
    return false;
  }
  return false;
}

exports.Construction = Construction;
exports.ConstructionHint = ConstructionHint;
exports.findVariable = findVariable;
exports.getChidScopes = getChidScopes;
exports.getScope = getScope;
exports.getVariableDeclaratorID = getVariableDeclaratorID;
exports.getVariableDef = getVariableDef;
exports.getVariableNode = getVariableNode;
exports.getVariables = getVariables;
exports.inspectConstruction = inspectConstruction;
exports.isNodeValueEqual = isNodeValueEqual;
