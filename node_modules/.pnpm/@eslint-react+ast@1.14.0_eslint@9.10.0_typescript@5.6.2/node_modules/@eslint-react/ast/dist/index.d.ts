import { O } from '@eslint-react/tools';
import { TSESTree as TSESTree$1, AST_NODE_TYPES } from '@typescript-eslint/types';
import { TSESTree } from '@typescript-eslint/utils';

type TSESTreeFunction = TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclaration | TSESTree.FunctionExpression;
type TSESTreeFunctionType = TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunction | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignature | TSESTreeFunction;
type TSESTreeClass = TSESTree.ClassDeclaration | TSESTree.ClassExpression;
type TSESTreeLoop = TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
type TSESTreeArrayTupleType = TSESTree.TSArrayType | TSESTree.TSTupleType;
type TSESTreeProperty = TSESTree.PropertyDefinition | TSESTree.TSIndexSignature | TSESTree.TSParameterProperty | TSESTree.TSPropertySignature;
type TSESTreeJSX = TSESTree.JSXAttribute | TSESTree.JSXChild | TSESTree.JSXClosingElement | TSESTree.JSXClosingFragment | TSESTree.JSXElement | TSESTree.JSXEmptyExpression | TSESTree.JSXExpression | TSESTree.JSXExpressionContainer | TSESTree.JSXFragment | TSESTree.JSXIdentifier | TSESTree.JSXIdentifierToken | TSESTree.JSXMemberExpression | TSESTree.JSXNamespacedName | TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment | TSESTree.JSXSpreadAttribute | TSESTree.JSXSpreadChild | TSESTree.JSXTagNameExpression | TSESTree.JSXText | TSESTree.JSXTextToken;
type TSESTreeDestructuringPattern = TSESTree.ArrayPattern | TSESTree.AssignmentPattern | TSESTree.ObjectPattern | TSESTree.RestElement;
type TSESTreeTypeDeclaration = TSESTree.TSInterfaceDeclaration | TSESTree.TSTypeAliasDeclaration;

type FunctionInitPath = 
/**
 * function Comp() { return <div />; }
 */
readonly [TSESTree$1.FunctionDeclaration]
/**
 * const Comp = () => <div />;
 * const Comp = function () { return <div />; };
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTreeFunction
]
/**
 * const Comp = React.memo(() => <div />);
 * const Comp = React.forwardRef(() => <div />);
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * const Comp = React.memo(React.forwardRef(() => <div />));
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.CallExpression,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * const Comps = {
 *  TopNav() { return <div />; },
 *  SidPanel: () => <div />,
 * }
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.ObjectExpression,
    TSESTree$1.Property,
    TSESTreeFunction
]
/**
 * const Comps = {
 *  TopNav: React.memo(() => <div />),
 *  SidPanel: React.forwardRef(() => <div />),
 * }
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.ObjectExpression,
    TSESTree$1.Property,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * const Comps = {
 * TopNav: React.memo(React.forwardRef(() => <div />)),
 * SidPanel: React.forwardRef(React.memo(() => <div />)),
 * }
 */
 | readonly [
    TSESTree$1.VariableDeclaration,
    TSESTree$1.VariableDeclarator,
    TSESTree$1.ObjectExpression,
    TSESTree$1.Property,
    TSESTree$1.CallExpression,
    TSESTree$1.CallExpression,
    TSESTreeFunction
]
/**
 * class Comp {
 *   TopNav() { return <div />; }
 * }
 */
 | readonly [
    TSESTree$1.ClassDeclaration,
    TSESTree$1.ClassBody,
    TSESTree$1.MethodDefinition,
    TSESTreeFunction
]
/**
 * class Comp {
 *   TopNav = () => <div />;
 * }
 */
 | readonly [
    TSESTree$1.ClassDeclaration,
    TSESTree$1.ClassBody,
    TSESTree$1.PropertyDefinition,
    TSESTreeFunction
];
declare function getFunctionInitPath(node: TSESTreeFunction): O.Option<FunctionInitPath>;
declare function hasCallInFunctionInitPath(callName: string): (initPath: O.Option<FunctionInitPath>) => boolean;

/**
 * Gets class identifier from ClassDeclaration or ClassExpression
 * @param node The AST node to check
 * @returns class identifier or null
 */
declare function getClassIdentifier(node: TSESTreeClass): O.Option<TSESTree$1.Identifier>;

/**
 * Gets the static name of a function AST node. For function declarations it is
 * easy. For anonymous function expressions it is much harder. If you search for
 * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places
 * where JS gives anonymous function expressions names. We roughly detect the
 * same AST nodes with some exceptions to better fit our use case.
 */

declare function getFunctionIdentifier(node: TSESTreeFunction): O.Option<TSESTree$1.Identifier>;

declare function getIdentifiersFromBinaryExpression(side: TSESTree$1.BinaryExpression | TSESTree$1.BinaryExpression["left"] | TSESTree$1.BinaryExpression["right"]): TSESTree$1.Identifier[];

declare function getLiteralValueType(input: bigint | boolean | null | number | string | symbol): "Null" | "Boolean" | "Number" | "String" | "BigInt" | "Symbol";

/**
 * Get all nested call expressions in a expression like node
 * @param node The node to get the nested call expressions from
 * @returns All nested call expressions
 */
declare function getNestedCallExpressions(node: TSESTree$1.Node): TSESTree$1.CallExpression[];

/**
 * Get all nested identifiers in a expression like node
 * @param node The node to get the nested identifiers from
 * @returns All nested identifiers
 */
declare function getNestedIdentifiers(node: TSESTree$1.Node): readonly TSESTree$1.Identifier[];

/**
 * Gets the nested return statements in the node that are within the same function
 * @param node The AST node
 * @returns The nested return statements in the node
 */
declare function getNestedReturnStatements(node: TSESTree$1.Node): readonly TSESTree$1.ReturnStatement[];

declare function getTopLevelIdentifier(node: TSESTree$1.Node): O.Option<TSESTree$1.Identifier>;

declare const is: <NodeType extends AST_NODE_TYPES>(nodeType: NodeType) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: NodeType;
}>;
declare const isOneOf: <NodeTypes extends readonly AST_NODE_TYPES[]>(nodeTypes: NodeTypes) => (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: NodeTypes[number];
}>;
declare const isFunction: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression;
declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.ArrowFunctionExpression | AST_NODE_TYPES.FunctionDeclaration | AST_NODE_TYPES.FunctionExpression | AST_NODE_TYPES.TSCallSignatureDeclaration | AST_NODE_TYPES.TSConstructSignatureDeclaration | AST_NODE_TYPES.TSDeclareFunction | AST_NODE_TYPES.TSEmptyBodyFunctionExpression | AST_NODE_TYPES.TSFunctionType | AST_NODE_TYPES.TSMethodSignature;
}>;
declare const isClass: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.ClassDeclaration | AST_NODE_TYPES.ClassExpression;
}>;
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.DoWhileStatement | AST_NODE_TYPES.ForInStatement | AST_NODE_TYPES.ForOfStatement | AST_NODE_TYPES.ForStatement | AST_NODE_TYPES.WhileStatement;
}>;
declare const isArrayTupleType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.TSArrayType | AST_NODE_TYPES.TSTupleType;
}>;
declare const isProperty: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.PropertyDefinition | AST_NODE_TYPES.TSIndexSignature | AST_NODE_TYPES.TSParameterProperty | AST_NODE_TYPES.TSPropertySignature;
}>;
declare const isJSXElement: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXElement;
declare const isJSXFragment: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.JSXFragment;
}>;
declare const isJSX: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.JSXAttribute | AST_NODE_TYPES.JSXClosingElement | AST_NODE_TYPES.JSXClosingFragment | AST_NODE_TYPES.JSXElement | AST_NODE_TYPES.JSXEmptyExpression | AST_NODE_TYPES.JSXExpressionContainer | AST_NODE_TYPES.JSXFragment | AST_NODE_TYPES.JSXIdentifier | AST_NODE_TYPES.JSXMemberExpression | AST_NODE_TYPES.JSXNamespacedName | AST_NODE_TYPES.JSXOpeningElement | AST_NODE_TYPES.JSXOpeningFragment | AST_NODE_TYPES.JSXSpreadAttribute | AST_NODE_TYPES.JSXSpreadChild | AST_NODE_TYPES.JSXText;
}>;
declare const isJSXTagNameExpression: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.JSXIdentifier | AST_NODE_TYPES.JSXMemberExpression | AST_NODE_TYPES.JSXNamespacedName;
}>;
declare const isDestructuringPattern: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.ArrayPattern | AST_NODE_TYPES.AssignmentPattern | AST_NODE_TYPES.ObjectPattern | AST_NODE_TYPES.RestElement;
}>;
declare const isTypeDeclaration: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.TSInterfaceDeclaration | AST_NODE_TYPES.TSTypeAliasDeclaration;
}>;
declare const isLeftHandSideExpression: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.ArrayExpression | AST_NODE_TYPES.ArrayPattern | AST_NODE_TYPES.ArrowFunctionExpression | AST_NODE_TYPES.CallExpression | AST_NODE_TYPES.ClassExpression | AST_NODE_TYPES.FunctionExpression | AST_NODE_TYPES.Identifier | AST_NODE_TYPES.JSXElement | AST_NODE_TYPES.JSXFragment | AST_NODE_TYPES.Literal | AST_NODE_TYPES.MemberExpression | AST_NODE_TYPES.MetaProperty | AST_NODE_TYPES.ObjectExpression | AST_NODE_TYPES.ObjectPattern | AST_NODE_TYPES.SequenceExpression | AST_NODE_TYPES.Super | AST_NODE_TYPES.TaggedTemplateExpression | AST_NODE_TYPES.TemplateLiteral | AST_NODE_TYPES.ThisExpression;
}>;
declare const isLeftHandSideExpressionType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: AST_NODE_TYPES.ArrayExpression | AST_NODE_TYPES.ArrayPattern | AST_NODE_TYPES.ArrowFunctionExpression | AST_NODE_TYPES.CallExpression | AST_NODE_TYPES.ClassExpression | AST_NODE_TYPES.FunctionExpression | AST_NODE_TYPES.Identifier | AST_NODE_TYPES.JSXElement | AST_NODE_TYPES.JSXFragment | AST_NODE_TYPES.Literal | AST_NODE_TYPES.MemberExpression | AST_NODE_TYPES.MetaProperty | AST_NODE_TYPES.ObjectExpression | AST_NODE_TYPES.ObjectPattern | AST_NODE_TYPES.SequenceExpression | AST_NODE_TYPES.Super | AST_NODE_TYPES.TaggedTemplateExpression | AST_NODE_TYPES.TemplateLiteral | AST_NODE_TYPES.ThisExpression | AST_NODE_TYPES.TSAsExpression | AST_NODE_TYPES.TSNonNullExpression | AST_NODE_TYPES.TSTypeAssertion;
}>;

declare function isEmptyFunction(node: TSESTreeFunction): boolean;

/**
 * Checks if the given node is a function expression or arrow function expression of a class method.
 * @param node The node to check.
 * @returns `true` if the node is a function expression or arrow function expression of a class method, `false` otherwise.
 */
declare const isFunctionOfClassMethod: (node: TSESTree$1.Node) => boolean;

/**
 * Checks if the given node is a function expression or arrow function expression of a class property.
 * @param node The node to check.
 * @returns `true` if the node is a function expression or arrow function expression of a class property, `false` otherwise.
 */
declare const isFunctionOfClassProperty: (node: TSESTree$1.Node) => boolean;

declare function isFunctionOfImmediatelyInvoked(node: TSESTreeFunction): boolean;

/**
 * Checks if the given node is a function expression or arrow function expression of a object method.
 * @param node The node to check.
 * @returns `true` if the node is a function expression or arrow function expression of a object method, `false` otherwise.
 */
declare const isFunctionOfObjectMethod: (node: TSESTree$1.Node) => boolean;

declare function isKeyLiteralLike(node: TSESTree$1.MemberExpression | TSESTree$1.MethodDefinition | TSESTree$1.Property | TSESTree$1.PropertyDefinition, property: TSESTree$1.Node): boolean;

declare function isMapCallLoose(node: TSESTree$1.Node): node is TSESTree$1.CallExpression;

/**
 * Check if a node is multiline
 * @param node The AST node to check
 * @returns  `true` if the node is multiline
 */
declare function isMultiLine(node: TSESTree$1.Node): boolean;

/**
 * Determines whether node equals to another node
 * @param a node to compare
 * @param b node to compare
 * @returns `true` if node equal
 * @see https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/src/util/isNodeEqual.ts
 */
declare const isNodeEqual: {
    (a: TSESTree$1.Node): (b: TSESTree$1.Node) => boolean;
    (a: TSESTree$1.Node, b: TSESTree$1.Node): boolean;
};

declare function isRegExpLiteral(node: TSESTree$1.Node): node is TSESTree$1.RegExpLiteral;

declare function isStringLiteral(node: TSESTree$1.Node): node is TSESTree$1.StringLiteral;

declare function isThisExpression(node: TSESTree$1.Expression): boolean;

/**
 * Returns human readable node name for given AST node
 * @param node AST node
 * @param getText A function that returns the text of the node in the source code
 * @returns Human readable node name
 */
declare function toReadableNodeName(node: TSESTree$1.Node, getText: (node: TSESTree$1.Node) => string): string;

/**
 * Returns human readable node type for given AST node
 * @param node AST node
 * @returns Human readable node type
 */
declare function toReadableNodeType(node: TSESTree$1.Node): "property" | "RegExp literal" | "Null literal" | "Boolean literal" | "Number literal" | "String literal" | "BigInt literal" | "Symbol literal" | "identifier" | "member expression" | "JSX attribute" | "JSX element" | "JSX fragment" | "JSX identifier" | "JSX text" | "JSX closing element" | "JSX closing fragment" | "JSX empty expression" | "JSX expression container" | "JSX member expression" | "JSX namespaced name" | "JSX opening element" | "JSX opening fragment" | "JSX spread attribute" | "JSX spread child" | "decorator" | "program" | "super" | "accessor property" | "array expression" | "array pattern" | "function expression" | "arrow function expression" | "assignment expression" | "assignment pattern" | "await expression" | "binary expression" | "block statement" | "break statement" | "call expression" | "catch clause" | "chain expression" | "class body" | "class declaration" | "class expression" | "conditional expression" | "continue statement" | "debugger statement" | "while statement" | "do while statement" | "empty statement" | "export all declaration" | "export default declaration" | "export named declaration" | "export specifier" | "expression statement" | "for in statement" | "for of statement" | "for statement" | "function declaration" | "if statement" | "import attribute" | "import declaration" | "import default specifier" | "import expression" | "import namespace specifier" | "import specifier" | "labeled statement" | "logical expression" | "meta property" | "method definition" | "new expression" | "object expression" | "object pattern" | "private identifier" | "property definition" | "rest element" | "return statement" | "sequence expression" | "spread element" | "static block" | "switch case" | "switch statement" | "tagged template expression" | "template element" | "template literal" | "this expression" | "throw statement" | "try statement" | "unary expression" | "update expression" | "variable declaration" | "variable declarator" | "with statement" | "yield expression" | "ts abstract accessor property" | "ts abstract keyword" | "ts abstract method definition" | "ts abstract property definition" | "ts any keyword" | "ts array type" | "ts as expression" | "ts async keyword" | "ts big int keyword" | "ts boolean keyword" | "ts call signature declaration" | "ts class implements" | "ts conditional type" | "ts constructor type" | "ts construct signature declaration" | "ts declare function" | "ts declare keyword" | "ts empty body function expression" | "ts enum body" | "ts enum declaration" | "ts enum member" | "ts export assignment" | "ts export keyword" | "ts external module reference" | "ts function type" | "ts import equals declaration" | "ts import type" | "ts indexed access type" | "ts index signature" | "ts infer type" | "ts instantiation expression" | "ts interface body" | "ts interface declaration" | "ts interface heritage" | "ts intersection type" | "ts intrinsic keyword" | "ts literal type" | "ts mapped type" | "ts method signature" | "ts module block" | "ts module declaration" | "ts named tuple member" | "ts namespace export declaration" | "ts never keyword" | "ts non null expression" | "ts null keyword" | "ts number keyword" | "ts object keyword" | "ts optional type" | "ts parameter property" | "ts private keyword" | "ts property signature" | "ts protected keyword" | "ts public keyword" | "ts qualified name" | "ts readonly keyword" | "ts rest type" | "ts satisfies expression" | "ts static keyword" | "ts string keyword" | "ts symbol keyword" | "ts template literal type" | "ts this type" | "ts tuple type" | "ts type alias declaration" | "ts type annotation" | "ts type assertion" | "ts type literal" | "ts type operator" | "ts type parameter" | "ts type parameter declaration" | "ts type parameter instantiation" | "ts type predicate" | "ts type query" | "ts type reference" | "ts undefined keyword" | "ts union type" | "ts unknown keyword" | "ts void keyword";
type ReadableNodeType = ReturnType<typeof toReadableNodeType>;

/**
 * Traverses up the AST tree until the predicate returns `true` or the root node is reached
 * @param node The AST node to start traversing from
 * @param predicate The predicate to check each node
 * @returns The first node that matches the predicate or `null` if no node matches
 */
declare const traverseUp: {
    (node: TSESTree$1.Node, predicate: (node: TSESTree$1.Node) => boolean): O.Option<TSESTree$1.Node>;
    (predicate: (node: TSESTree$1.Node) => boolean): (node: TSESTree$1.Node) => O.Option<TSESTree$1.Node>;
};

/**
 * Traverses up the AST tree until the predicate returns `true` or the root node is reached
 * @template T
 * @param node The AST node to start traversing from
 * @param predicate The predicate to check each node. **must be a type guard**
 * @returns The first node that matches the predicate or `null` if no node matches
 */
declare const traverseUpGuard: {
    <T extends TSESTree$1.Node>(node: TSESTree$1.Node, predicate: (node: TSESTree$1.Node) => node is T): O.Option<T>;
    <T extends TSESTree$1.Node>(predicate: (node: TSESTree$1.Node) => node is T): (node: TSESTree$1.Node) => O.Option<T>;
};

export { type FunctionInitPath, type ReadableNodeType, type TSESTreeArrayTupleType, type TSESTreeClass, type TSESTreeDestructuringPattern, type TSESTreeFunction, type TSESTreeFunctionType, type TSESTreeJSX, type TSESTreeLoop, type TSESTreeProperty, type TSESTreeTypeDeclaration, getClassIdentifier, getFunctionIdentifier, getFunctionInitPath, getIdentifiersFromBinaryExpression, getLiteralValueType, getNestedCallExpressions, getNestedIdentifiers, getNestedReturnStatements, getTopLevelIdentifier, hasCallInFunctionInitPath, is, isArrayTupleType, isClass, isDestructuringPattern, isEmptyFunction, isFunction, isFunctionOfClassMethod, isFunctionOfClassProperty, isFunctionOfImmediatelyInvoked, isFunctionOfObjectMethod, isFunctionType, isJSX, isJSXElement, isJSXFragment, isJSXTagNameExpression, isKeyLiteralLike, isLeftHandSideExpression, isLeftHandSideExpressionType, isLoop, isMapCallLoose, isMultiLine, isNodeEqual, isOneOf, isProperty, isRegExpLiteral, isStringLiteral, isThisExpression, isTypeDeclaration, toReadableNodeName, toReadableNodeType, traverseUp, traverseUpGuard };
