import { TSESTree } from '@typescript-eslint/types';
import { Scope } from '@typescript-eslint/scope-manager';
import { O } from '@eslint-react/tools';
import { TSESTree as TSESTree$1 } from '@typescript-eslint/utils';

/**
 * Returns the tag name associated with a JSXOpeningElement.
 * @param node The visited JSXOpeningElement node object.
 * @returns The element's tag name.
 */
declare function getElementName(node: TSESTree.JSXOpeningElement | TSESTree.JSXOpeningFragment): string;

declare function getElementType(jsxCtx: {
    getScope: (node: TSESTree.Node) => Scope;
}, components?: Map<string, string>, polymorphicPropName?: string): (node: TSESTree.JSXOpeningElement) => string;

/**
 * Get the name of a JSX attribute with namespace
 * @param node The JSX attribute node
 * @returns string
 */
declare function getPropName(node: TSESTree$1.JSXAttribute): string;
declare function getProp(props: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], propName: string, initialScope: Scope): O.Option<TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute>;
/**
 * Gets and resolves the static value of a JSX attribute
 * @param attribute The JSX attribute to get the value of
 * @param initialScope The initial scope to start from
 * @returns  The static value of the given JSX attribute
 */
declare function getPropValue(attribute: TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute, initialScope: Scope): O.None<{
    value: unknown;
} | null> | O.Some<{
    value: unknown;
} | null>;
/**
 * @param properties The properties to search in
 * @param initialScope The initial scope to start from
 * @param seenProps The properties that have already been seen
 * @returns A function that searches for a property in the given properties
 */
declare function findPropInProperties(properties: (TSESTree$1.Property | TSESTree$1.RestElement | TSESTree$1.SpreadElement)[], initialScope: Scope, seenProps?: string[]): (propName: string) => O.Option<(typeof properties)[number]>;
/**
 * @param attributes The attributes to search in
 * @param initialScope The initial scope to start from
 * @returns A function that searches for a property in the given attributes
 */
declare function findPropInAttributes(attributes: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], initialScope: Scope): (propName: string) => O.Option<NonNullable<TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute | undefined>>;

/**
 * Check if the given prop name is present in the given attributes
 * @param attributes The attributes to search in
 * @param propName The prop name to search for
 * @param initialScope The initial scope to start from
 * @returns `true` if the given prop name is present in the given properties
 */
declare function hasProp(attributes: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[], propName: string, initialScope: Scope): boolean;
/**
 * Check if any of the given prop names are present in the given attributes
 * @param attributes The attributes to search in
 * @param propNames The prop names to search for
 * @param initialScope The initial scope to start from
 * @returns `true` if any of the given prop names are present in the given attributes
 */
declare function hasAnyProp(attributes: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[], propNames: string[], initialScope: Scope): boolean;
/**
 * Check if all of the given prop names are present in the given attributes
 * @param attributes The attributes to search in
 * @param propNames The prop names to search for
 * @param initialScope The initial scope to start from
 * @returns `true` if all of the given prop names are present in the given attributes
 */
declare function hasEveryProp(attributes: (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)[], propNames: string[], initialScope: Scope): boolean;

declare function isKeyedElement(node: TSESTree.Node, initialScope: Scope): boolean;
/**
 * Check if a node is a `JSXElement` of `User-Defined Component` type
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXElement` of `User-Defined Component` type
 */
declare function isUserDefinedElement(node: TSESTree.Node): boolean;
/**
 * Check if a node is a `JSXFragment` of `Built-in Component` type
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXFragment` of `Built-in Component` type
 */
declare function isBuiltInElement(node: TSESTree.Node): boolean;

declare const JSXValueHint: {
    readonly None: 0n;
    readonly SkipNullLiteral: bigint;
    readonly SkipUndefinedLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipCreateElement: bigint;
    readonly SkipEmptyArray: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_JSX_VALUE_HINT: bigint;
/**
 * Check if a node is a JSX value
 * @param node The AST node to check
 * @param jsxCtx The requirements for the check
 * @param jsxCtx.getScope The function to get the scope of a node
 * @param hint The `JSXValueHint` to use
 * @returns boolean
 */
declare function isJSXValue(node: TSESTree$1.Node | null | undefined, jsxCtx: {
    getScope: (node: TSESTree$1.Node) => Scope;
}, hint?: bigint): boolean;

/**
 * Check if a node is a Literal or JSXText
 * @param node The AST node to check
 * @returns boolean `true` if the node is a Literal or JSXText
 */
declare const isLiteral: (node: TSESTree.Node | null | undefined) => node is TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.JSXText;
/**
 * Check if a Literal or JSXText node is whitespace
 * @param node The AST node to check
 * @returns boolean `true` if the node is whitespace
 */
declare function isWhiteSpace(node: TSESTree.JSXText | TSESTree.Literal): boolean;
/**
 * Check if a Literal or JSXText node is a line break
 * @param node The AST node to check
 * @returns boolean
 */
declare function isLineBreak(node: TSESTree.Node): boolean;
/**
 * Check if a Literal or JSXText node is padding spaces
 * @param node The AST node to check
 * @returns boolean
 */
declare function isPaddingSpaces(node: TSESTree.Node): boolean;

/**
 * Traverses up prop node
 * @param node The AST node to start traversing from
 * @param predicate The predicate to check each node
 * @returns prop node if found
 */
declare function traverseUpProp(node: TSESTree.Node, predicate?: (node: TSESTree.JSXAttribute) => boolean): O.Option<TSESTree.JSXAttribute>;

export { DEFAULT_JSX_VALUE_HINT, JSXValueHint, findPropInAttributes, findPropInProperties, getElementName, getElementType, getProp, getPropName, getPropValue, hasAnyProp, hasEveryProp, hasProp, isBuiltInElement, isJSXValue, isKeyedElement, isLineBreak, isLiteral, isPaddingSpaces, isUserDefinedElement, isWhiteSpace, traverseUpProp };
