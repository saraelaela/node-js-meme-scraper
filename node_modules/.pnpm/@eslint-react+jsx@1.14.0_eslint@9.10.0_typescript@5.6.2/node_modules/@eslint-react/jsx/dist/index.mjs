import { AST_NODE_TYPES } from '@typescript-eslint/types';
import { O, isString, F } from '@eslint-react/tools';
import * as AST from '@eslint-react/ast';
import * as VAR from '@eslint-react/var';
import { getStaticValue } from '@typescript-eslint/utils/ast-utils';
import { match, P } from 'ts-pattern';

// src/get-element-name.ts
function resolveJSXMemberExpressions(object, property) {
  if (object.type === AST_NODE_TYPES.JSXMemberExpression) {
    return `${resolveJSXMemberExpressions(object.object, object.property)}.${property.name}`;
  }
  if (object.type === AST_NODE_TYPES.JSXNamespacedName) {
    return `${object.namespace.name}:${object.name.name}.${property.name}`;
  }
  return `${object.name}.${property.name}`;
}
function getElementName(node) {
  if (node.type === AST_NODE_TYPES.JSXOpeningFragment) {
    return "<>";
  }
  const { name } = node;
  if (name.type === AST_NODE_TYPES.JSXMemberExpression) {
    const { object, property } = name;
    return resolveJSXMemberExpressions(object, property);
  }
  if (name.type === AST_NODE_TYPES.JSXNamespacedName) {
    return `${name.namespace.name}:${name.name.name}`;
  }
  return name.name;
}
function getPropName(node) {
  switch (node.name.type) {
    case AST_NODE_TYPES.JSXIdentifier:
      return node.name.name;
    case AST_NODE_TYPES.JSXNamespacedName:
      return `${node.name.namespace.name}:${node.name.name.name}`;
  }
}
function getProp(props, propName, initialScope) {
  return findPropInAttributes(props, initialScope)(propName);
}
function getPropValue(attribute, initialScope) {
  if (attribute.type === AST_NODE_TYPES.JSXAttribute && "value" in attribute) {
    const { value } = attribute;
    if (value === null) return O.none();
    if (value.type === AST_NODE_TYPES.Literal) return O.some(getStaticValue(value, initialScope));
    if (value.type === AST_NODE_TYPES.JSXExpressionContainer) {
      return O.some(getStaticValue(value.expression, initialScope));
    }
    return O.none();
  }
  const { argument } = attribute;
  return O.some(getStaticValue(argument, initialScope));
}
function findPropInProperties(properties, initialScope, seenProps = []) {
  return (propName) => {
    return O.fromNullable(
      properties.findLast((prop) => {
        switch (true) {
          case (prop.type === AST_NODE_TYPES.Property && "name" in prop.key && prop.key.name === propName):
            return true;
          case prop.type === AST_NODE_TYPES.SpreadElement:
            switch (true) {
              case prop.argument.type === AST_NODE_TYPES.Identifier: {
                const { name } = prop.argument;
                const maybeInit = O.flatMap(
                  VAR.findVariable(name, initialScope),
                  VAR.getVariableNode(0)
                );
                if (O.isNone(maybeInit)) return false;
                const init = maybeInit.value;
                if (!AST.is(AST_NODE_TYPES.ObjectExpression)(init)) return false;
                if (seenProps.includes(name)) return false;
                return O.isSome(
                  findPropInProperties(init.properties, initialScope, [...seenProps, name])(propName)
                );
              }
              case prop.argument.type === AST_NODE_TYPES.ObjectExpression: {
                return O.isSome(
                  findPropInProperties(prop.argument.properties, initialScope, seenProps)(propName)
                );
              }
              default: {
                return false;
              }
            }
          case prop.type === AST_NODE_TYPES.RestElement:
            return false;
          default:
            return false;
        }
      })
    );
  };
}
function findPropInAttributes(attributes, initialScope) {
  return (propName) => {
    return O.fromNullable(
      attributes.findLast((attr) => {
        switch (attr.type) {
          case AST_NODE_TYPES.JSXAttribute:
            return getPropName(attr) === propName;
          case AST_NODE_TYPES.JSXSpreadAttribute:
            switch (attr.argument.type) {
              case AST_NODE_TYPES.Identifier: {
                const { name } = attr.argument;
                const maybeInit = O.flatMap(
                  VAR.findVariable(name, initialScope),
                  VAR.getVariableNode(0)
                );
                if (O.isNone(maybeInit)) return false;
                const init = maybeInit.value;
                if (!AST.is(AST_NODE_TYPES.ObjectExpression)(init)) return false;
                return O.isSome(findPropInProperties(init.properties, initialScope)(propName));
              }
              case AST_NODE_TYPES.ObjectExpression:
                return O.isSome(findPropInProperties(attr.argument.properties, initialScope)(propName));
              case AST_NODE_TYPES.MemberExpression:
                return false;
              case AST_NODE_TYPES.CallExpression:
                return false;
              default:
                return false;
            }
          default:
            return false;
        }
      })
    );
  };
}

// src/get-element-type.ts
function getElementType(jsxCtx, components, polymorphicPropName) {
  return (node) => {
    const elementName = getElementName(node);
    if (elementName === elementName.toLowerCase()) return elementName;
    const asElementName = components?.get(elementName);
    if (isString(asElementName)) return asElementName;
    const initialScope = jsxCtx.getScope(node);
    return F.pipe(
      O.fromNullable(polymorphicPropName),
      O.flatMap(findPropInAttributes(node.attributes, initialScope)),
      O.flatMap((attr) => getPropValue(attr, jsxCtx.getScope(attr))),
      O.flatMapNullable((v) => v?.value),
      O.filter(isString),
      O.getOrElse(() => elementName)
    );
  };
}
function hasProp(attributes, propName, initialScope) {
  return O.isSome(findPropInAttributes(attributes, initialScope)(propName));
}
function hasAnyProp(attributes, propNames, initialScope) {
  return propNames.some((propName) => hasProp(attributes, propName, initialScope));
}
function hasEveryProp(attributes, propNames, initialScope) {
  return propNames.every((propName) => hasProp(attributes, propName, initialScope));
}
function isKeyedElement(node, initialScope) {
  return node.type === AST_NODE_TYPES.JSXElement && hasProp(node.openingElement.attributes, "key", initialScope);
}
function isUserDefinedElement(node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && /^[A-Z]/u.test(node.openingElement.name.name);
}
function isBuiltInElement(node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && node.openingElement.name.name.toLowerCase() === node.openingElement.name.name && /^[a-z]/u.test(node.openingElement.name.name);
}
var JSXValueHint = {
  None: 0n,
  SkipNullLiteral: 1n << 0n,
  SkipUndefinedLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipCreateElement: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  StrictArray: 1n << 7n,
  StrictLogical: 1n << 8n,
  StrictConditional: 1n << 9n
};
var DEFAULT_JSX_VALUE_HINT = 0n | JSXValueHint.SkipUndefinedLiteral | JSXValueHint.SkipBooleanLiteral;
function isJSXValue(node, jsxCtx, hint = DEFAULT_JSX_VALUE_HINT) {
  if (!node) return false;
  return match(node).with({ type: AST_NODE_TYPES.JSXElement }, F.constTrue).with({ type: AST_NODE_TYPES.JSXFragment }, F.constTrue).with({ type: AST_NODE_TYPES.JSXMemberExpression }, F.constTrue).with({ type: AST_NODE_TYPES.JSXNamespacedName }, F.constTrue).with({ type: AST_NODE_TYPES.Literal }, (node2) => {
    return match(node2.value).with(null, () => !(hint & JSXValueHint.SkipNullLiteral)).with(P.boolean, () => !(hint & JSXValueHint.SkipBooleanLiteral)).with(P.string, () => !(hint & JSXValueHint.SkipStringLiteral)).with(P.number, () => !(hint & JSXValueHint.SkipNumberLiteral)).otherwise(F.constFalse);
  }).with({ type: AST_NODE_TYPES.TemplateLiteral }, () => !(hint & JSXValueHint.SkipStringLiteral)).with({ type: AST_NODE_TYPES.ArrayExpression }, (node2) => {
    if (hint & JSXValueHint.StrictArray) return node2.elements.every((n) => isJSXValue(n, jsxCtx, hint));
    return node2.elements.some((n) => isJSXValue(n, jsxCtx, hint));
  }).with({ type: AST_NODE_TYPES.ConditionalExpression }, (node2) => {
    function leftHasJSX(node3) {
      if (Array.isArray(node3.consequent)) {
        if (node3.consequent.length === 0) return !(hint & JSXValueHint.SkipEmptyArray);
        if (hint & JSXValueHint.StrictArray) {
          return node3.consequent.every((n) => isJSXValue(n, jsxCtx, hint));
        }
        return node3.consequent.some((n) => isJSXValue(n, jsxCtx, hint));
      }
      return isJSXValue(node3.consequent, jsxCtx, hint);
    }
    function rightHasJSX(node3) {
      return isJSXValue(node3.alternate, jsxCtx, hint);
    }
    if (hint & JSXValueHint.StrictConditional) {
      return leftHasJSX(node2) && rightHasJSX(node2);
    }
    return leftHasJSX(node2) || rightHasJSX(node2);
  }).with({ type: AST_NODE_TYPES.LogicalExpression }, (node2) => {
    if (hint & JSXValueHint.StrictLogical) {
      return isJSXValue(node2.left, jsxCtx, hint) && isJSXValue(node2.right, jsxCtx, hint);
    }
    return isJSXValue(node2.left, jsxCtx, hint) || isJSXValue(node2.right, jsxCtx, hint);
  }).with({ type: AST_NODE_TYPES.SequenceExpression }, (node2) => {
    const exp = node2.expressions.at(-1);
    return isJSXValue(exp, jsxCtx, hint);
  }).with({ type: AST_NODE_TYPES.CallExpression }, (node2) => {
    if (hint & JSXValueHint.SkipCreateElement) return false;
    return match(node2.callee).with({ type: AST_NODE_TYPES.Identifier, name: "createElement" }, F.constTrue).with({ type: AST_NODE_TYPES.MemberExpression, property: { name: "createElement" } }, F.constTrue).otherwise(F.constFalse);
  }).with({ type: AST_NODE_TYPES.Identifier }, (node2) => {
    const { name } = node2;
    if (name === "undefined") return !(hint & JSXValueHint.SkipUndefinedLiteral);
    if (AST.isJSXTagNameExpression(node2)) return true;
    const initialScope = jsxCtx.getScope(node2);
    return F.pipe(
      VAR.findVariable(name, initialScope),
      O.flatMap(VAR.getVariableNode(0)),
      O.exists((n) => isJSXValue(n, jsxCtx, hint))
    );
  }).otherwise(F.constFalse);
}
var isLiteral = AST.isOneOf([AST_NODE_TYPES.Literal, AST_NODE_TYPES.JSXText]);
function isWhiteSpace(node) {
  return isString(node.value) && node.value.trim() === "";
}
function isLineBreak(node) {
  return isLiteral(node) && isWhiteSpace(node) && AST.isMultiLine(node);
}
function isPaddingSpaces(node) {
  return isLiteral(node) && isWhiteSpace(node) && node.raw.includes("\n");
}
function traverseUpProp(node, predicate = F.constTrue) {
  const guard = (node2) => {
    return node2.type === AST_NODE_TYPES.JSXAttribute && predicate(node2);
  };
  return AST.traverseUpGuard(node, guard);
}

export { DEFAULT_JSX_VALUE_HINT, JSXValueHint, findPropInAttributes, findPropInProperties, getElementName, getElementType, getProp, getPropName, getPropValue, hasAnyProp, hasEveryProp, hasProp, isBuiltInElement, isJSXValue, isKeyedElement, isLineBreak, isLiteral, isPaddingSpaces, isUserDefinedElement, isWhiteSpace, traverseUpProp };
