'use strict';

var types = require('@typescript-eslint/types');
var tools = require('@eslint-react/tools');
var AST = require('@eslint-react/ast');
var VAR = require('@eslint-react/var');
var astUtils = require('@typescript-eslint/utils/ast-utils');
var tsPattern = require('ts-pattern');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST__namespace = /*#__PURE__*/_interopNamespace(AST);
var VAR__namespace = /*#__PURE__*/_interopNamespace(VAR);

// src/get-element-name.ts
function resolveJSXMemberExpressions(object, property) {
  if (object.type === types.AST_NODE_TYPES.JSXMemberExpression) {
    return `${resolveJSXMemberExpressions(object.object, object.property)}.${property.name}`;
  }
  if (object.type === types.AST_NODE_TYPES.JSXNamespacedName) {
    return `${object.namespace.name}:${object.name.name}.${property.name}`;
  }
  return `${object.name}.${property.name}`;
}
function getElementName(node) {
  if (node.type === types.AST_NODE_TYPES.JSXOpeningFragment) {
    return "<>";
  }
  const { name } = node;
  if (name.type === types.AST_NODE_TYPES.JSXMemberExpression) {
    const { object, property } = name;
    return resolveJSXMemberExpressions(object, property);
  }
  if (name.type === types.AST_NODE_TYPES.JSXNamespacedName) {
    return `${name.namespace.name}:${name.name.name}`;
  }
  return name.name;
}
function getPropName(node) {
  switch (node.name.type) {
    case types.AST_NODE_TYPES.JSXIdentifier:
      return node.name.name;
    case types.AST_NODE_TYPES.JSXNamespacedName:
      return `${node.name.namespace.name}:${node.name.name.name}`;
  }
}
function getProp(props, propName, initialScope) {
  return findPropInAttributes(props, initialScope)(propName);
}
function getPropValue(attribute, initialScope) {
  if (attribute.type === types.AST_NODE_TYPES.JSXAttribute && "value" in attribute) {
    const { value } = attribute;
    if (value === null) return tools.O.none();
    if (value.type === types.AST_NODE_TYPES.Literal) return tools.O.some(astUtils.getStaticValue(value, initialScope));
    if (value.type === types.AST_NODE_TYPES.JSXExpressionContainer) {
      return tools.O.some(astUtils.getStaticValue(value.expression, initialScope));
    }
    return tools.O.none();
  }
  const { argument } = attribute;
  return tools.O.some(astUtils.getStaticValue(argument, initialScope));
}
function findPropInProperties(properties, initialScope, seenProps = []) {
  return (propName) => {
    return tools.O.fromNullable(
      properties.findLast((prop) => {
        switch (true) {
          case (prop.type === types.AST_NODE_TYPES.Property && "name" in prop.key && prop.key.name === propName):
            return true;
          case prop.type === types.AST_NODE_TYPES.SpreadElement:
            switch (true) {
              case prop.argument.type === types.AST_NODE_TYPES.Identifier: {
                const { name } = prop.argument;
                const maybeInit = tools.O.flatMap(
                  VAR__namespace.findVariable(name, initialScope),
                  VAR__namespace.getVariableNode(0)
                );
                if (tools.O.isNone(maybeInit)) return false;
                const init = maybeInit.value;
                if (!AST__namespace.is(types.AST_NODE_TYPES.ObjectExpression)(init)) return false;
                if (seenProps.includes(name)) return false;
                return tools.O.isSome(
                  findPropInProperties(init.properties, initialScope, [...seenProps, name])(propName)
                );
              }
              case prop.argument.type === types.AST_NODE_TYPES.ObjectExpression: {
                return tools.O.isSome(
                  findPropInProperties(prop.argument.properties, initialScope, seenProps)(propName)
                );
              }
              default: {
                return false;
              }
            }
          case prop.type === types.AST_NODE_TYPES.RestElement:
            return false;
          default:
            return false;
        }
      })
    );
  };
}
function findPropInAttributes(attributes, initialScope) {
  return (propName) => {
    return tools.O.fromNullable(
      attributes.findLast((attr) => {
        switch (attr.type) {
          case types.AST_NODE_TYPES.JSXAttribute:
            return getPropName(attr) === propName;
          case types.AST_NODE_TYPES.JSXSpreadAttribute:
            switch (attr.argument.type) {
              case types.AST_NODE_TYPES.Identifier: {
                const { name } = attr.argument;
                const maybeInit = tools.O.flatMap(
                  VAR__namespace.findVariable(name, initialScope),
                  VAR__namespace.getVariableNode(0)
                );
                if (tools.O.isNone(maybeInit)) return false;
                const init = maybeInit.value;
                if (!AST__namespace.is(types.AST_NODE_TYPES.ObjectExpression)(init)) return false;
                return tools.O.isSome(findPropInProperties(init.properties, initialScope)(propName));
              }
              case types.AST_NODE_TYPES.ObjectExpression:
                return tools.O.isSome(findPropInProperties(attr.argument.properties, initialScope)(propName));
              case types.AST_NODE_TYPES.MemberExpression:
                return false;
              case types.AST_NODE_TYPES.CallExpression:
                return false;
              default:
                return false;
            }
          default:
            return false;
        }
      })
    );
  };
}

// src/get-element-type.ts
function getElementType(jsxCtx, components, polymorphicPropName) {
  return (node) => {
    const elementName = getElementName(node);
    if (elementName === elementName.toLowerCase()) return elementName;
    const asElementName = components?.get(elementName);
    if (tools.isString(asElementName)) return asElementName;
    const initialScope = jsxCtx.getScope(node);
    return tools.F.pipe(
      tools.O.fromNullable(polymorphicPropName),
      tools.O.flatMap(findPropInAttributes(node.attributes, initialScope)),
      tools.O.flatMap((attr) => getPropValue(attr, jsxCtx.getScope(attr))),
      tools.O.flatMapNullable((v) => v?.value),
      tools.O.filter(tools.isString),
      tools.O.getOrElse(() => elementName)
    );
  };
}
function hasProp(attributes, propName, initialScope) {
  return tools.O.isSome(findPropInAttributes(attributes, initialScope)(propName));
}
function hasAnyProp(attributes, propNames, initialScope) {
  return propNames.some((propName) => hasProp(attributes, propName, initialScope));
}
function hasEveryProp(attributes, propNames, initialScope) {
  return propNames.every((propName) => hasProp(attributes, propName, initialScope));
}
function isKeyedElement(node, initialScope) {
  return node.type === types.AST_NODE_TYPES.JSXElement && hasProp(node.openingElement.attributes, "key", initialScope);
}
function isUserDefinedElement(node) {
  return node.type === types.AST_NODE_TYPES.JSXElement && node.openingElement.name.type === types.AST_NODE_TYPES.JSXIdentifier && /^[A-Z]/u.test(node.openingElement.name.name);
}
function isBuiltInElement(node) {
  return node.type === types.AST_NODE_TYPES.JSXElement && node.openingElement.name.type === types.AST_NODE_TYPES.JSXIdentifier && node.openingElement.name.name.toLowerCase() === node.openingElement.name.name && /^[a-z]/u.test(node.openingElement.name.name);
}
var JSXValueHint = {
  None: 0n,
  SkipNullLiteral: 1n << 0n,
  SkipUndefinedLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipCreateElement: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  StrictArray: 1n << 7n,
  StrictLogical: 1n << 8n,
  StrictConditional: 1n << 9n
};
var DEFAULT_JSX_VALUE_HINT = 0n | JSXValueHint.SkipUndefinedLiteral | JSXValueHint.SkipBooleanLiteral;
function isJSXValue(node, jsxCtx, hint = DEFAULT_JSX_VALUE_HINT) {
  if (!node) return false;
  return tsPattern.match(node).with({ type: types.AST_NODE_TYPES.JSXElement }, tools.F.constTrue).with({ type: types.AST_NODE_TYPES.JSXFragment }, tools.F.constTrue).with({ type: types.AST_NODE_TYPES.JSXMemberExpression }, tools.F.constTrue).with({ type: types.AST_NODE_TYPES.JSXNamespacedName }, tools.F.constTrue).with({ type: types.AST_NODE_TYPES.Literal }, (node2) => {
    return tsPattern.match(node2.value).with(null, () => !(hint & JSXValueHint.SkipNullLiteral)).with(tsPattern.P.boolean, () => !(hint & JSXValueHint.SkipBooleanLiteral)).with(tsPattern.P.string, () => !(hint & JSXValueHint.SkipStringLiteral)).with(tsPattern.P.number, () => !(hint & JSXValueHint.SkipNumberLiteral)).otherwise(tools.F.constFalse);
  }).with({ type: types.AST_NODE_TYPES.TemplateLiteral }, () => !(hint & JSXValueHint.SkipStringLiteral)).with({ type: types.AST_NODE_TYPES.ArrayExpression }, (node2) => {
    if (hint & JSXValueHint.StrictArray) return node2.elements.every((n) => isJSXValue(n, jsxCtx, hint));
    return node2.elements.some((n) => isJSXValue(n, jsxCtx, hint));
  }).with({ type: types.AST_NODE_TYPES.ConditionalExpression }, (node2) => {
    function leftHasJSX(node3) {
      if (Array.isArray(node3.consequent)) {
        if (node3.consequent.length === 0) return !(hint & JSXValueHint.SkipEmptyArray);
        if (hint & JSXValueHint.StrictArray) {
          return node3.consequent.every((n) => isJSXValue(n, jsxCtx, hint));
        }
        return node3.consequent.some((n) => isJSXValue(n, jsxCtx, hint));
      }
      return isJSXValue(node3.consequent, jsxCtx, hint);
    }
    function rightHasJSX(node3) {
      return isJSXValue(node3.alternate, jsxCtx, hint);
    }
    if (hint & JSXValueHint.StrictConditional) {
      return leftHasJSX(node2) && rightHasJSX(node2);
    }
    return leftHasJSX(node2) || rightHasJSX(node2);
  }).with({ type: types.AST_NODE_TYPES.LogicalExpression }, (node2) => {
    if (hint & JSXValueHint.StrictLogical) {
      return isJSXValue(node2.left, jsxCtx, hint) && isJSXValue(node2.right, jsxCtx, hint);
    }
    return isJSXValue(node2.left, jsxCtx, hint) || isJSXValue(node2.right, jsxCtx, hint);
  }).with({ type: types.AST_NODE_TYPES.SequenceExpression }, (node2) => {
    const exp = node2.expressions.at(-1);
    return isJSXValue(exp, jsxCtx, hint);
  }).with({ type: types.AST_NODE_TYPES.CallExpression }, (node2) => {
    if (hint & JSXValueHint.SkipCreateElement) return false;
    return tsPattern.match(node2.callee).with({ type: types.AST_NODE_TYPES.Identifier, name: "createElement" }, tools.F.constTrue).with({ type: types.AST_NODE_TYPES.MemberExpression, property: { name: "createElement" } }, tools.F.constTrue).otherwise(tools.F.constFalse);
  }).with({ type: types.AST_NODE_TYPES.Identifier }, (node2) => {
    const { name } = node2;
    if (name === "undefined") return !(hint & JSXValueHint.SkipUndefinedLiteral);
    if (AST__namespace.isJSXTagNameExpression(node2)) return true;
    const initialScope = jsxCtx.getScope(node2);
    return tools.F.pipe(
      VAR__namespace.findVariable(name, initialScope),
      tools.O.flatMap(VAR__namespace.getVariableNode(0)),
      tools.O.exists((n) => isJSXValue(n, jsxCtx, hint))
    );
  }).otherwise(tools.F.constFalse);
}
var isLiteral = AST__namespace.isOneOf([types.AST_NODE_TYPES.Literal, types.AST_NODE_TYPES.JSXText]);
function isWhiteSpace(node) {
  return tools.isString(node.value) && node.value.trim() === "";
}
function isLineBreak(node) {
  return isLiteral(node) && isWhiteSpace(node) && AST__namespace.isMultiLine(node);
}
function isPaddingSpaces(node) {
  return isLiteral(node) && isWhiteSpace(node) && node.raw.includes("\n");
}
function traverseUpProp(node, predicate = tools.F.constTrue) {
  const guard = (node2) => {
    return node2.type === types.AST_NODE_TYPES.JSXAttribute && predicate(node2);
  };
  return AST__namespace.traverseUpGuard(node, guard);
}

exports.DEFAULT_JSX_VALUE_HINT = DEFAULT_JSX_VALUE_HINT;
exports.JSXValueHint = JSXValueHint;
exports.findPropInAttributes = findPropInAttributes;
exports.findPropInProperties = findPropInProperties;
exports.getElementName = getElementName;
exports.getElementType = getElementType;
exports.getProp = getProp;
exports.getPropName = getPropName;
exports.getPropValue = getPropValue;
exports.hasAnyProp = hasAnyProp;
exports.hasEveryProp = hasEveryProp;
exports.hasProp = hasProp;
exports.isBuiltInElement = isBuiltInElement;
exports.isJSXValue = isJSXValue;
exports.isKeyedElement = isKeyedElement;
exports.isLineBreak = isLineBreak;
exports.isLiteral = isLiteral;
exports.isPaddingSpaces = isPaddingSpaces;
exports.isUserDefinedElement = isUserDefinedElement;
exports.isWhiteSpace = isWhiteSpace;
exports.traverseUpProp = traverseUpProp;
