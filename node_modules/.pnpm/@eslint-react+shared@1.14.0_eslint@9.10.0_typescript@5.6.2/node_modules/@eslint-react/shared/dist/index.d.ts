import { ESLintUtils } from '@typescript-eslint/utils';

/**
 * The NPM scope for this project.
 */
declare const NPM_SCOPE = "@eslint-react";
/**
 * The GitHub repository for this project.
 */
declare const GITHUB_URL = "https://github.com/rel1cx/eslint-react";
/**
 * The URL to the project's website.
 */
declare const WEBSITE_URL = "https://eslint-react.xyz";
/**
 * Regular expression for matching a PascalCase string.
 */
declare const RE_PASCAL_CASE: RegExp;
/**
 * Regular expression for matching a camelCase string.
 */
declare const RE_CAMEL_CASE: RegExp;
/**
 * Regular expression for matching a kebab-case string.
 */
declare const RE_KEBAB_CASE: RegExp;
/**
 * Regular expression for matching a snake_case string.
 */
declare const RE_SNAKE_CASE: RegExp;
/**
 * Regular expression for matching a CONSTANT_CASE string.
 */
declare const RE_CONSTANT_CASE: RegExp;
declare const RE_JAVASCRIPT_PROTOCOL: RegExp;
/**
 * @internal
 */
declare const HOST_HTML_COMPONENT_TYPES: readonly ["aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "menu", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
/**
 * @internal
 */
declare const HOST_SVG_COMPONENT_TYPES: readonly ["a", "animate", "animateMotion", "animateTransform", "circle", "clipPath", "defs", "desc", "discard", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "foreignObject", "g", "hatch", "hatchpath", "image", "line", "linearGradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tspan", "use", "view"];
declare const REACT_BUILD_IN_HOOKS: readonly ["useActionState", "useCallback", "useContext", "useDebugValue", "useDeferredValue", "useEffect", "useId", "useImperativeHandle", "useInsertionEffect", "useLayoutEffect", "useMemo", "useOptimistic", "useReducer", "useRef", "useState", "useSyncExternalStore", "useTransition"];

/**
 * Get the ESLint rule creator for a plugin.
 * @internal
 * @param pluginName The name of the plugin.
 * @returns The ESLint rule creator.
 */
declare const createRuleForPlugin: (pluginName: string) => <Options extends readonly unknown[], MessageIds extends string>({ meta, name, ...rule }: Readonly<ESLintUtils.RuleWithMetaAndName<Options, MessageIds, unknown>>) => ESLintUtils.RuleModule<MessageIds, Options, unknown, ESLintUtils.RuleListener>;

/**
 * Array issue type.
 */
interface ArrayIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'array';
    /**
     * The expected property.
     */
    readonly expected: 'Array';
}

/**
 * Array schema type.
 */
interface ArraySchema<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TMessage extends ErrorMessage<ArrayIssue> | undefined> extends BaseSchema<InferInput<TItem>[], InferOutput<TItem>[], ArrayIssue | InferIssue<TItem>> {
    /**
     * The schema type.
     */
    readonly type: 'array';
    /**
     * The schema reference.
     */
    readonly reference: typeof array;
    /**
     * The expected property.
     */
    readonly expects: 'Array';
    /**
     * The array item schema.
     */
    readonly item: TItem;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an array schema.
 *
 * @param item The item schema.
 *
 * @returns An array schema.
 */
declare function array<const TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(item: TItem): ArraySchema<TItem, undefined>;
/**
 * Creates an array schema.
 *
 * @param item The item schema.
 * @param message The error message.
 *
 * @returns An array schema.
 */
declare function array<const TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TMessage extends ErrorMessage<ArrayIssue> | undefined>(item: TItem, message: TMessage): ArraySchema<TItem, TMessage>;

/**
 * Boolean issue type.
 */
interface BooleanIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'boolean';
    /**
     * The expected property.
     */
    readonly expected: 'boolean';
}
/**
 * Boolean schema type.
 */
interface BooleanSchema<TMessage extends ErrorMessage<BooleanIssue> | undefined> extends BaseSchema<boolean, boolean, BooleanIssue> {
    /**
     * The schema type.
     */
    readonly type: 'boolean';
    /**
     * The schema reference.
     */
    readonly reference: typeof boolean;
    /**
     * The expected property.
     */
    readonly expects: 'boolean';
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates a boolean schema.
 *
 * @returns A boolean schema.
 */
declare function boolean(): BooleanSchema<undefined>;
/**
 * Creates a boolean schema.
 *
 * @param message The error message.
 *
 * @returns A boolean schema.
 */
declare function boolean<const TMessage extends ErrorMessage<BooleanIssue> | undefined>(message: TMessage): BooleanSchema<TMessage>;

/**
 * Class type.
 */
type Class = new (...args: any[]) => any;
/**
 * Instance issue type.
 */
interface InstanceIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'instance';
    /**
     * The expected property.
     */
    readonly expected: string;
}
/**
 * Instance schema type.
 */
interface InstanceSchema<TClass extends Class, TMessage extends ErrorMessage<InstanceIssue> | undefined> extends BaseSchema<InstanceType<TClass>, InstanceType<TClass>, InstanceIssue> {
    /**
     * The schema type.
     */
    readonly type: 'instance';
    /**
     * The schema reference.
     */
    readonly reference: typeof instance;
    /**
     * The class of the instance.
     */
    readonly class: TClass;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an instance schema.
 *
 * @param class_ The class of the instance.
 *
 * @returns An instance schema.
 */
declare function instance<TClass extends Class>(class_: TClass): InstanceSchema<TClass, undefined>;
/**
 * Creates an instance schema.
 *
 * @param class_ The class of the instance.
 * @param message The error message.
 *
 * @returns An instance schema.
 */
declare function instance<TClass extends Class, const TMessage extends ErrorMessage<InstanceIssue> | undefined>(class_: TClass, message: TMessage): InstanceSchema<TClass, TMessage>;

/**
 * Infer nullish output type.
 */
type InferNullishOutput<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, null | undefined>> = [TDefault] extends [never] ? InferOutput<TWrapped> | null | undefined : NonNullish<InferOutput<TWrapped>> | Extract<DefaultValue<TDefault>, null | undefined>;

/**
 * Nullish schema type.
 */
interface NullishSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, null | undefined>> extends BaseSchema<InferInput<TWrapped> | null | undefined, InferNullishOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'nullish';
    /**
     * The schema reference.
     */
    readonly reference: typeof nullish;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | null | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullish<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): NullishSchema<TWrapped, never>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullish<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, null | undefined>>(wrapped: TWrapped, default_: TDefault): NullishSchema<TWrapped, TDefault>;

/**
 * Nullish schema async type.
 */
interface NullishSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, null | undefined>> extends BaseSchemaAsync<InferInput<TWrapped> | null | undefined, InferNullishOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'nullish';
    /**
     * The schema reference.
     */
    readonly reference: typeof nullishAsync;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | null | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullishAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): NullishSchemaAsync<TWrapped, never>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullishAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, null | undefined>>(wrapped: TWrapped, default_: TDefault): NullishSchemaAsync<TWrapped, TDefault>;

/**
 * Object issue type.
 */
interface ObjectIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'object';
    /**
     * The expected property.
     */
    readonly expected: 'Object';
}

/**
 * Object schema type.
 */
interface ObjectSchema<TEntries extends ObjectEntries, TMessage extends ErrorMessage<ObjectIssue> | undefined> extends BaseSchema<InferObjectInput<TEntries>, InferObjectOutput<TEntries>, ObjectIssue | InferObjectIssue<TEntries>> {
    /**
     * The schema type.
     */
    readonly type: 'object';
    /**
     * The schema reference.
     */
    readonly reference: typeof object;
    /**
     * The expected property.
     */
    readonly expects: 'Object';
    /**
     * The entries schema.
     */
    readonly entries: TEntries;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an object schema.
 *
 * Hint: This schema removes unknown entries. The output will only include the
 * entries you specify. To include unknown entries, use `looseObject`. To
 * return an issue for unknown entries, use `strictObject`. To include and
 * validate unknown entries, use `objectWithRest`.
 *
 * @param entries The entries schema.
 *
 * @returns An object schema.
 */
declare function object<const TEntries extends ObjectEntries>(entries: TEntries): ObjectSchema<TEntries, undefined>;
/**
 * Creates an object schema.
 *
 * Hint: This schema removes unknown entries. The output will only include the
 * entries you specify. To include unknown entries, use `looseObject`. To
 * return an issue for unknown entries, use `strictObject`. To include and
 * validate unknown entries, use `objectWithRest`.
 *
 * @param entries The entries schema.
 * @param message The error message.
 *
 * @returns An object schema.
 */
declare function object<const TEntries extends ObjectEntries, const TMessage extends ErrorMessage<ObjectIssue> | undefined>(entries: TEntries, message: TMessage): ObjectSchema<TEntries, TMessage>;

/**
 * Infer optional output type.
 */
type InferOptionalOutput<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, undefined>> = [TDefault] extends [never] ? InferOutput<TWrapped> | undefined : NonOptional<InferOutput<TWrapped>> | Extract<DefaultValue<TDefault>, undefined>;

/**
 * Optional schema type.
 */
interface OptionalSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, undefined>> extends BaseSchema<InferInput<TWrapped> | undefined, InferOptionalOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof optional;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A optional schema.
 */
declare function optional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): OptionalSchema<TWrapped, never>;
/**
 * Creates a optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A optional schema.
 */
declare function optional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, undefined>>(wrapped: TWrapped, default_: TDefault): OptionalSchema<TWrapped, TDefault>;

/**
 * Optional schema async type.
 */
interface OptionalSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, undefined>> extends BaseSchemaAsync<InferInput<TWrapped> | undefined, InferOptionalOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof optionalAsync;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An optional schema.
 */
declare function optionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): OptionalSchemaAsync<TWrapped, never>;
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An optional schema.
 */
declare function optionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, undefined>>(wrapped: TWrapped, default_: TDefault): OptionalSchemaAsync<TWrapped, TDefault>;

/**
 * String issue type.
 */
interface StringIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'string';
    /**
     * The expected property.
     */
    readonly expected: 'string';
}
/**
 * String schema type.
 */
interface StringSchema<TMessage extends ErrorMessage<StringIssue> | undefined> extends BaseSchema<string, string, StringIssue> {
    /**
     * The schema type.
     */
    readonly type: 'string';
    /**
     * The schema reference.
     */
    readonly reference: typeof string;
    /**
     * The expected property.
     */
    readonly expects: 'string';
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates a string schema.
 *
 * @returns A string schema.
 */
declare function string(): StringSchema<undefined>;
/**
 * Creates a string schema.
 *
 * @param message The error message.
 *
 * @returns A string schema.
 */
declare function string<const TMessage extends ErrorMessage<StringIssue> | undefined>(message: TMessage): StringSchema<TMessage>;

/**
 * Schema with pipe type.
 */
type SchemaWithPipe<TPipe extends [
    BaseSchema<unknown, unknown, BaseIssue<unknown>>,
    ...PipeItem<any, unknown, BaseIssue<unknown>>[]
]> = Omit<FirstTupleItem<TPipe>, '_run' | '_types'> & {
    /**
     * The pipe items.
     */
    readonly pipe: TPipe;
    /**
     * Parses unknown input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: Dataset<unknown, never>, config: Config<InferIssue<FirstTupleItem<TPipe>>>) => Dataset<InferOutput<LastTupleItem<TPipe>>, InferIssue<TPipe[number]>>;
    /**
     * Input, output and issue type.
     *
     * @internal
     */
    readonly _types?: {
        readonly input: InferInput<FirstTupleItem<TPipe>>;
        readonly output: InferOutput<LastTupleItem<TPipe>>;
        readonly issue: InferIssue<TPipe[number]>;
    };
};

/**
 * Schema with pipe async type.
 */
type SchemaWithPipeAsync<TPipe extends [
    (BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>),
    ...(PipeItem<any, unknown, BaseIssue<unknown>> | PipeItemAsync<any, unknown, BaseIssue<unknown>>)[]
]> = Omit<FirstTupleItem<TPipe>, 'async' | '_run' | '_types'> & {
    /**
     * The pipe items.
     */
    readonly pipe: TPipe;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Parses unknown input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: Dataset<unknown, never>, config: Config<InferIssue<FirstTupleItem<TPipe>>>) => Promise<Dataset<InferOutput<LastTupleItem<TPipe>>, InferIssue<TPipe[number]>>>;
    /**
     * Input, output and issue type.
     *
     * @internal
     */
    readonly _types?: {
        readonly input: InferInput<FirstTupleItem<TPipe>>;
        readonly output: InferOutput<LastTupleItem<TPipe>>;
        readonly issue: InferIssue<TPipe[number]>;
    };
};

/**
 * Base metadata type.
 */
interface BaseMetadata<TInput> {
    /**
     * The object kind.
     */
    readonly kind: 'metadata';
    /**
     * The metadata type.
     */
    readonly type: string;
    /**
     * The metadata reference.
     */
    readonly reference: (...args: any[]) => BaseMetadata<any>;
    /**
     * Input, output and issue type.
     *
     * @internal
     */
    readonly _types?: {
        readonly input: TInput;
        readonly output: TInput;
        readonly issue: never;
    };
}

/**
 * Typed dataset type.
 */
interface TypedDataset<TValue, TIssue extends BaseIssue<unknown>> {
    /**
     * Whether is's typed.
     */
    typed: true;
    /**
     * The dataset value.
     */
    value: TValue;
    /**
     * The dataset issues.
     */
    issues?: [TIssue, ...TIssue[]];
}
/**
 * Untyped dataset type.
 */
interface UntypedDataset<TIssue extends BaseIssue<unknown>> {
    /**
     * Whether is's typed.
     */
    typed: false;
    /**
     * The dataset value.
     */
    value: unknown;
    /**
     * The dataset issues.
     */
    issues?: [TIssue, ...TIssue[]];
}
/**
 * Dataset type.
 */
type Dataset<TValue, TIssue extends BaseIssue<unknown>> = TypedDataset<TValue, TIssue> | UntypedDataset<TIssue>;

/**
 * Base schema type.
 */
interface BaseSchema<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'schema';
    /**
     * The schema type.
     */
    readonly type: string;
    /**
     * The schema reference.
     */
    readonly reference: (...args: any[]) => BaseSchema<unknown, unknown, BaseIssue<unknown>>;
    /**
     * The expected property.
     */
    readonly expects: string;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Parses unknown input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: Dataset<unknown, never>, config: Config<TIssue>) => Dataset<TOutput, TIssue>;
    /**
     * Input, output and issue type.
     *
     * @internal
     */
    readonly _types?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    };
}
/**
 * Base schema async type.
 */
interface BaseSchemaAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseSchema<TInput, TOutput, TIssue>, 'reference' | 'async' | '_run'> {
    /**
     * The schema reference.
     */
    readonly reference: (...args: any[]) => BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Parses unknown input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: Dataset<unknown, never>, config: Config<TIssue>) => Promise<Dataset<TOutput, TIssue>>;
}

/**
 * Base transformation type.
 */
interface BaseTransformation<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'transformation';
    /**
     * The transformation type.
     */
    readonly type: string;
    /**
     * The transformation reference.
     */
    readonly reference: (...args: any[]) => BaseTransformation<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Transforms known input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: TypedDataset<TInput, never>, config: Config<TIssue>) => Dataset<TOutput, TIssue>;
    /**
     * Input, output and issue type.
     *
     * @internal
     */
    readonly _types?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    };
}
/**
 * Base transformation async type.
 */
interface BaseTransformationAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseTransformation<TInput, TOutput, TIssue>, 'reference' | 'async' | '_run'> {
    /**
     * The transformation reference.
     */
    readonly reference: (...args: any[]) => BaseTransformation<any, any, BaseIssue<unknown>> | BaseTransformationAsync<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Transforms known input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: TypedDataset<TInput, never>, config: Config<TIssue>) => Promise<Dataset<TOutput, TIssue>>;
}

/**
 * Base validation type.
 */
interface BaseValidation<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'validation';
    /**
     * The validation type.
     */
    readonly type: string;
    /**
     * The validation reference.
     */
    readonly reference: (...args: any[]) => BaseValidation<any, any, BaseIssue<unknown>>;
    /**
     * The expected property.
     */
    readonly expects: string | null;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Validates known input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: Dataset<TInput, BaseIssue<unknown>>, config: Config<TIssue>) => Dataset<TOutput, BaseIssue<unknown> | TIssue>;
    /**
     * Input, output and issue type.
     *
     * @internal
     */
    readonly _types?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    };
}
/**
 * Base validation async type.
 */
interface BaseValidationAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseValidation<TInput, TOutput, TIssue>, 'reference' | 'async' | '_run'> {
    /**
     * The validation reference.
     */
    readonly reference: (...args: any[]) => BaseValidation<any, any, BaseIssue<unknown>> | BaseValidationAsync<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Validates known input.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly _run: (dataset: Dataset<TInput, BaseIssue<unknown>>, config: Config<TIssue>) => Promise<Dataset<TOutput, BaseIssue<unknown> | TIssue>>;
}

/**
 * Infer input type.
 */
type InferInput<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['_types']>['input'];
/**
 * Infer output type.
 */
type InferOutput<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['_types']>['output'];
/**
 * Infer issue type.
 */
type InferIssue<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['_types']>['issue'];
/**
 * Extracts `null` and `undefined` from a type.
 */
type NonNullish<TValue> = TValue extends null | undefined ? never : TValue;
/**
 * Extracts `undefined` from a type.
 */
type NonOptional<TValue> = TValue extends undefined ? never : TValue;
/**
 * Constructs a type that is maybe readonly.
 */
type MaybeReadonly<TValue> = TValue | Readonly<TValue>;
/**
 * Constructs a type that is maybe a promise.
 */
type MaybePromise<TValue> = TValue | Promise<TValue>;
/**
 * Prettifies a type for better readability.
 *
 * Hint: This type has no effect and is only used so that TypeScript displays
 * the final type in the preview instead of the utility types used.
 */
type Prettify<TObject> = {
    [TKey in keyof TObject]: TObject[TKey];
} & {};
/**
 * Marks specific keys as optional.
 */
type MarkOptional<TObject, TKeys extends keyof TObject> = Omit<TObject, TKeys> & Partial<Pick<TObject, TKeys>>;
/**
 * Extracts first tuple item.
 */
type FirstTupleItem<TTuple extends [unknown, ...unknown[]]> = TTuple[0];
/**
 * Extracts last tuple item.
 */
type LastTupleItem<TTuple extends [unknown, ...unknown[]]> = TTuple[TTuple extends [unknown, ...infer TRest] ? TRest['length'] : never];

/**
 * Error message type.
 */
type ErrorMessage<TIssue extends BaseIssue<unknown>> = ((issue: TIssue) => string) | string;
/**
 * Default type.
 */
type Default<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TInput extends null | undefined> = MaybeReadonly<InferInput<TWrapped> | TInput> | ((dataset?: Dataset<TInput, never>, config?: Config<InferIssue<TWrapped>>) => MaybeReadonly<InferInput<TWrapped> | TInput>);
/**
 * Default async type.
 */
type DefaultAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TInput extends null | undefined> = MaybeReadonly<InferInput<TWrapped> | TInput> | ((dataset?: Dataset<TInput, never>, config?: Config<InferIssue<TWrapped>>) => MaybePromise<MaybeReadonly<InferInput<TWrapped> | TInput>>);
/**
 * Default value type.
 */
type DefaultValue<TDefault extends Default<BaseSchema<unknown, unknown, BaseIssue<unknown>>, null | undefined> | DefaultAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, null | undefined>> = TDefault extends DefaultAsync<infer TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, infer TInput> ? TDefault extends (dataset?: Dataset<TInput, never>, config?: Config<InferIssue<TWrapped>>) => MaybePromise<InferInput<TWrapped> | TInput> ? Awaited<ReturnType<TDefault>> : TDefault : never;

/**
 * Object entries type.
 */
interface ObjectEntries {
    [key: string]: BaseSchema<unknown, unknown, BaseIssue<unknown>>;
}
/**
 * Object entries async type.
 */
interface ObjectEntriesAsync {
    [key: string]: BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>;
}
/**
 * Question mark schema type.
 *
 * TODO: Document that for simplicity and bundle size, we currently do not
 * distinguish between `undefined` and missing keys when using `optional` and
 * `nullish`.
 */
type QuestionMarkSchema = NullishSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | NullishSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown>;
/**
 * Has default type.
 */
type HasDefault<TSchema extends QuestionMarkSchema> = [
    TSchema['default']
] extends [never] ? false : true;
/**
 * Exact optional input type.
 */
type ExactOptionalInput<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>> = TSchema extends OptionalSchema<infer TWrapped, never> | OptionalSchemaAsync<infer TWrapped, never> ? ExactOptionalInput<TWrapped> : InferInput<TSchema>;
/**
 * Exact optional output type.
 */
type ExactOptionalOutput<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>> = TSchema extends OptionalSchema<infer TWrapped, never> | OptionalSchemaAsync<infer TWrapped, never> ? HasDefault<TSchema> extends true ? InferOutput<TSchema> : ExactOptionalOutput<TWrapped> : InferOutput<TSchema>;
/**
 * Infer entries input type.
 */
type InferEntriesInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    -readonly [TKey in keyof TEntries]: ExactOptionalInput<TEntries[TKey]>;
};
/**
 * Infer entries output type.
 */
type InferEntriesOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    -readonly [TKey in keyof TEntries]: ExactOptionalOutput<TEntries[TKey]>;
};
/**
 * Optional input keys type.
 */
type OptionalInputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends QuestionMarkSchema ? TKey : never;
}[keyof TEntries];
/**
 * Optional output keys type.
 */
type OptionalOutputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends QuestionMarkSchema ? undefined extends InferOutput<TEntries[TKey]> ? HasDefault<TEntries[TKey]> extends false ? TKey : never : never : never;
}[keyof TEntries];
/**
 * Input with question marks type.
 */
type InputWithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends InferEntriesInput<TEntries> | InferEntriesOutput<TEntries>> = MarkOptional<TObject, OptionalInputKeys<TEntries>>;
/**
 * Output with question marks type.
 */
type OutputWithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends InferEntriesInput<TEntries> | InferEntriesOutput<TEntries>> = MarkOptional<TObject, OptionalOutputKeys<TEntries>>;
/**
 * Readonly output keys type.
 */
type ReadonlyOutputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends SchemaWithPipe<infer TPipe> | SchemaWithPipeAsync<infer TPipe> ? ReadonlyAction<any> extends TPipe[number] ? TKey : never : never;
}[keyof TEntries];
/**
 * Output with readonly type.
 */
type OutputWithReadonly<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends OutputWithQuestionMarks<TEntries, InferEntriesOutput<TEntries>>> = Readonly<TObject> & Pick<TObject, Exclude<keyof TObject, ReadonlyOutputKeys<TEntries>>>;
/**
 * Infer object input type.
 */
type InferObjectInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = Prettify<InputWithQuestionMarks<TEntries, InferEntriesInput<TEntries>>>;
/**
 * Infer object output type.
 */
type InferObjectOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = Prettify<OutputWithReadonly<TEntries, OutputWithQuestionMarks<TEntries, InferEntriesOutput<TEntries>>>>;
/**
 * Infer object issue type.
 */
type InferObjectIssue<TEntries extends ObjectEntries | ObjectEntriesAsync> = InferIssue<TEntries[keyof TEntries]>;

/**
 * Array path item type.
 */
interface ArrayPathItem {
    /**
     * The path item type.
     */
    readonly type: 'array';
    /**
     * The path item origin.
     */
    readonly origin: 'value';
    /**
     * The path item input.
     */
    readonly input: MaybeReadonly<unknown[]>;
    /**
     * The path item key.
     */
    readonly key: number;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Map path item type.
 */
interface MapPathItem {
    /**
     * The path item type.
     */
    readonly type: 'map';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: Map<unknown, unknown>;
    /**
     * The path item key.
     */
    readonly key: unknown;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Object path item type.
 */
interface ObjectPathItem {
    /**
     * The path item type.
     */
    readonly type: 'object';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: Record<string, unknown>;
    /**
     * The path item key.
     */
    readonly key: string;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Set path item type.
 */
interface SetPathItem {
    /**
     * The path item type.
     */
    readonly type: 'set';
    /**
     * The path item origin.
     */
    readonly origin: 'value';
    /**
     * The path item input.
     */
    readonly input: Set<unknown>;
    /**
     * The path item key.
     */
    readonly key: null;
    /**
     * The path item key.
     */
    readonly value: unknown;
}
/**
 * Unknown path item type.
 */
interface UnknownPathItem {
    /**
     * The path item type.
     */
    readonly type: 'unknown';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: unknown;
    /**
     * The path item key.
     */
    readonly key: unknown;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Issue path item type.
 *
 * TODO: Document that the input of the path may be different from the input of
 * the issue.
 */
type IssuePathItem = ArrayPathItem | MapPathItem | ObjectPathItem | SetPathItem | UnknownPathItem;
/**
 * Base issue type.
 */
interface BaseIssue<TInput> extends Config<BaseIssue<TInput>> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema' | 'validation' | 'transformation';
    /**
     * The issue type.
     */
    readonly type: string;
    /**
     * The raw input data.
     */
    readonly input: TInput;
    /**
     * The expected property.
     */
    readonly expected: string | null;
    /**
     * The received property.
     */
    readonly received: string;
    /**
     * The error message.
     */
    readonly message: string;
    /**
     * The input requirement.
     */
    readonly requirement?: unknown | undefined;
    /**
     * The issue path.
     *
     * TODO: Investigate if it is possible to make the path type safe based on the
     * input.
     */
    readonly path?: [IssuePathItem, ...IssuePathItem[]] | undefined;
    /**
     * The sub issues.
     */
    readonly issues?: [BaseIssue<TInput>, ...BaseIssue<TInput>[]] | undefined;
}

/**
 * Config type.
 */
interface Config<TIssue extends BaseIssue<unknown>> {
    /**
     * The selected language.
     */
    readonly lang?: string | undefined;
    /**
     * The error message.
     */
    readonly message?: ErrorMessage<TIssue> | undefined;
    /**
     * Whether it was abort early.
     */
    readonly abortEarly?: boolean | undefined;
    /**
     * Whether the pipe was abort early.
     */
    readonly abortPipeEarly?: boolean | undefined;
}

/**
 * Pipe action type.
 */
type PipeAction<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseValidation<TInput, TOutput, TIssue> | BaseTransformation<TInput, TOutput, TIssue> | BaseMetadata<TInput>;
/**
 * Pipe action async type.
 */
type PipeActionAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseValidationAsync<TInput, TOutput, TIssue> | BaseTransformationAsync<TInput, TOutput, TIssue>;
/**
 * Pipe item type.
 */
type PipeItem<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseSchema<TInput, TOutput, TIssue> | PipeAction<TInput, TOutput, TIssue>;
/**
 * Pipe item async type.
 */
type PipeItemAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseSchemaAsync<TInput, TOutput, TIssue> | PipeActionAsync<TInput, TOutput, TIssue>;

/**
 * Readonly action type.
 */
interface ReadonlyAction<TInput> extends BaseTransformation<TInput, Readonly<TInput>, never> {
    /**
     * The action type.
     */
    readonly type: 'readonly';
    /**
     * The action reference.
     */
    readonly reference: typeof readonly;
}
/**
 * Creates a readonly transformation action.
 *
 * @returns A readonly action.
 */
declare function readonly<TInput>(): ReadonlyAction<TInput>;

/**
 * @internal
 * @description
 * This allows the rule to know some key information before checking for user-defined hooks.
 * For example, the position of the `deps` argument for the user-defined `useCustomEffect` hook that represents the built-in `useEffect` hook.
 */
declare const CustomHookSchema: ObjectSchema<{}, undefined>;
/**
 * @internal
 */
declare const CustomAttributeSchema: ObjectSchema<{
    /**
     * The name of the attribute in the user-defined component.
     * @example
     * "to"
     */
    readonly name: StringSchema<undefined>;
    /**
     * The name of the attribute in the built-in component.
     * @example
     * "href"
     */
    readonly as: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * Whether the attribute is controlled or not in the user-defined component.
     * @example
     * `true`
     */
    readonly controlled: OptionalSchema<BooleanSchema<undefined>, never>;
    /**
     * The default value of the attribute in the user-defined component.
     * @example
     * `"/"`
     */
    readonly defaultValue: OptionalSchema<StringSchema<undefined>, never>;
}, undefined>;
/**
 * @internal
 * @description
 * This will provide some key information to the rule before checking for user-defined components.
 * For example:
 * Which attribute is used as the `href` prop for the user-defined `Link` component that represents the built-in `a` element.
 * Which attributes are used as `children` props for a user-defined `Button` component to receive children of that component.
 */
declare const CustomComponentSchema: ObjectSchema<{
    /**
     * The name of the user-defined component.
     * @example
     * "Link"
     */
    readonly name: StringSchema<undefined>;
    /**
     * The ESQuery selector to select the component precisely.
     * @example
     * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
     */
    readonly selector: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * The name of the built-in component that the user-defined component represents.
     * @example
     * "a"
     */
    readonly as: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * Pre-defined attributes that are used in the user-defined component.
     * @example
     * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
     */
    readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
        /**
         * The name of the attribute in the user-defined component.
         * @example
         * "to"
         */
        readonly name: StringSchema<undefined>;
        /**
         * The name of the attribute in the built-in component.
         * @example
         * "href"
         */
        readonly as: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * Whether the attribute is controlled or not in the user-defined component.
         * @example
         * `true`
         */
        readonly controlled: OptionalSchema<BooleanSchema<undefined>, never>;
        /**
         * The default value of the attribute in the user-defined component.
         * @example
         * `"/"`
         */
        readonly defaultValue: OptionalSchema<StringSchema<undefined>, never>;
    }, undefined>, undefined>, never>;
}, undefined>;
declare const CustomComponentNormalizedSchema: ObjectSchema<{
    readonly name: StringSchema<undefined>;
    readonly as: OptionalSchema<StringSchema<undefined>, never>;
    readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
        /**
         * The name of the attribute in the user-defined component.
         * @example
         * "to"
         */
        readonly name: StringSchema<undefined>;
        /**
         * The name of the attribute in the built-in component.
         * @example
         * "href"
         */
        readonly as: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * Whether the attribute is controlled or not in the user-defined component.
         * @example
         * `true`
         */
        readonly controlled: OptionalSchema<BooleanSchema<undefined>, never>;
        /**
         * The default value of the attribute in the user-defined component.
         * @example
         * `"/"`
         */
        readonly defaultValue: OptionalSchema<StringSchema<undefined>, never>;
    }, undefined>, undefined>, readonly []>;
    readonly re: InstanceSchema<RegExpConstructor, undefined>;
    readonly selector: OptionalSchema<StringSchema<undefined>, never>;
}, undefined>;
/**
 * @internal
 */
declare const ESLintReactSettingsSchema: ObjectSchema<{
    /**
     * The source where React is imported from.
     * @description This allows to specify a custom import location for React when not using the official distribution.
     * @default `"react"`
     * @example `"@pika/react"`
     */
    readonly importSource: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * The identifier that’s used for JSX Element creation.
     * @default `"createElement"`
     */
    readonly jsxPragma: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * The identifier that’s used for JSX fragment elements.
     * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
     * @default `"Fragment"`
     */
    readonly jsxPragmaFrag: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * The name of the prop that is used for polymorphic components.
     * @description This is used to determine the type of the component.
     * @example `"as"`
     */
    readonly polymorphicPropName: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * @internal
     */
    readonly strict: OptionalSchema<BooleanSchema<undefined>, never>;
    /**
     * @internal
     */
    readonly skipImportCheck: OptionalSchema<BooleanSchema<undefined>, true>;
    /**
     * React version to use, "detect" means auto detect React version from the project’s dependencies.
     * If `importSource` is specified, an equivalent version of React should be provided here.
     * @example `"18.3.1"`
     * @default `"detect"`
     */
    readonly version: OptionalSchema<StringSchema<undefined>, never>;
    /**
     * An array of user-defined components
     * @description This is used to inform the ESLint React plugins how to treat these components during checks.
     * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
     */
    readonly additionalComponents: OptionalSchema<ArraySchema<ObjectSchema<{
        /**
         * The name of the user-defined component.
         * @example
         * "Link"
         */
        readonly name: StringSchema<undefined>;
        /**
         * The ESQuery selector to select the component precisely.
         * @example
         * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
         */
        readonly selector: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The name of the built-in component that the user-defined component represents.
         * @example
         * "a"
         */
        readonly as: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * Pre-defined attributes that are used in the user-defined component.
         * @example
         * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
         */
        readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
            /**
             * The name of the attribute in the user-defined component.
             * @example
             * "to"
             */
            readonly name: StringSchema<undefined>;
            /**
             * The name of the attribute in the built-in component.
             * @example
             * "href"
             */
            readonly as: OptionalSchema<StringSchema<undefined>, never>;
            /**
             * Whether the attribute is controlled or not in the user-defined component.
             * @example
             * `true`
             */
            readonly controlled: OptionalSchema<BooleanSchema<undefined>, never>;
            /**
             * The default value of the attribute in the user-defined component.
             * @example
             * `"/"`
             */
            readonly defaultValue: OptionalSchema<StringSchema<undefined>, never>;
        }, undefined>, undefined>, never>;
    }, undefined>, undefined>, never>;
    /**
     * A object of aliases for React built-in hooks.
     * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
     * @example `{ useLayoutEffect: ["useIsomorphicLayoutEffect"] }`
     */
    readonly additionalHooks: OptionalSchema<ObjectSchema<{
        readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
    }, undefined>, never>;
}, undefined>;
/**
 * @internal
 */
declare const ESLintSettingsSchema: OptionalSchema<ObjectSchema<{
    readonly "react-x": OptionalSchema<ObjectSchema<{
        /**
         * The source where React is imported from.
         * @description This allows to specify a custom import location for React when not using the official distribution.
         * @default `"react"`
         * @example `"@pika/react"`
         */
        readonly importSource: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The identifier that’s used for JSX Element creation.
         * @default `"createElement"`
         */
        readonly jsxPragma: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The identifier that’s used for JSX fragment elements.
         * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
         * @default `"Fragment"`
         */
        readonly jsxPragmaFrag: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The name of the prop that is used for polymorphic components.
         * @description This is used to determine the type of the component.
         * @example `"as"`
         */
        readonly polymorphicPropName: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * @internal
         */
        readonly strict: OptionalSchema<BooleanSchema<undefined>, never>;
        /**
         * @internal
         */
        readonly skipImportCheck: OptionalSchema<BooleanSchema<undefined>, true>;
        /**
         * React version to use, "detect" means auto detect React version from the project’s dependencies.
         * If `importSource` is specified, an equivalent version of React should be provided here.
         * @example `"18.3.1"`
         * @default `"detect"`
         */
        readonly version: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * An array of user-defined components
         * @description This is used to inform the ESLint React plugins how to treat these components during checks.
         * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
         */
        readonly additionalComponents: OptionalSchema<ArraySchema<ObjectSchema<{
            /**
             * The name of the user-defined component.
             * @example
             * "Link"
             */
            readonly name: StringSchema<undefined>;
            /**
             * The ESQuery selector to select the component precisely.
             * @example
             * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
             */
            readonly selector: OptionalSchema<StringSchema<undefined>, never>;
            /**
             * The name of the built-in component that the user-defined component represents.
             * @example
             * "a"
             */
            readonly as: OptionalSchema<StringSchema<undefined>, never>;
            /**
             * Pre-defined attributes that are used in the user-defined component.
             * @example
             * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
             */
            readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
                /**
                 * The name of the attribute in the user-defined component.
                 * @example
                 * "to"
                 */
                readonly name: StringSchema<undefined>;
                /**
                 * The name of the attribute in the built-in component.
                 * @example
                 * "href"
                 */
                readonly as: OptionalSchema<StringSchema<undefined>, never>;
                /**
                 * Whether the attribute is controlled or not in the user-defined component.
                 * @example
                 * `true`
                 */
                readonly controlled: OptionalSchema<BooleanSchema<undefined>, never>;
                /**
                 * The default value of the attribute in the user-defined component.
                 * @example
                 * `"/"`
                 */
                readonly defaultValue: OptionalSchema<StringSchema<undefined>, never>;
            }, undefined>, undefined>, never>;
        }, undefined>, undefined>, never>;
        /**
         * A object of aliases for React built-in hooks.
         * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
         * @example `{ useLayoutEffect: ["useIsomorphicLayoutEffect"] }`
         */
        readonly additionalHooks: OptionalSchema<ObjectSchema<{
            readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>, never>;
    /** @deprecated Use `react-x` instead */
    readonly reactOptions: OptionalSchema<ObjectSchema<{
        /**
         * The source where React is imported from.
         * @description This allows to specify a custom import location for React when not using the official distribution.
         * @default `"react"`
         * @example `"@pika/react"`
         */
        readonly importSource: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The identifier that’s used for JSX Element creation.
         * @default `"createElement"`
         */
        readonly jsxPragma: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The identifier that’s used for JSX fragment elements.
         * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
         * @default `"Fragment"`
         */
        readonly jsxPragmaFrag: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * The name of the prop that is used for polymorphic components.
         * @description This is used to determine the type of the component.
         * @example `"as"`
         */
        readonly polymorphicPropName: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * @internal
         */
        readonly strict: OptionalSchema<BooleanSchema<undefined>, never>;
        /**
         * @internal
         */
        readonly skipImportCheck: OptionalSchema<BooleanSchema<undefined>, true>;
        /**
         * React version to use, "detect" means auto detect React version from the project’s dependencies.
         * If `importSource` is specified, an equivalent version of React should be provided here.
         * @example `"18.3.1"`
         * @default `"detect"`
         */
        readonly version: OptionalSchema<StringSchema<undefined>, never>;
        /**
         * An array of user-defined components
         * @description This is used to inform the ESLint React plugins how to treat these components during checks.
         * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
         */
        readonly additionalComponents: OptionalSchema<ArraySchema<ObjectSchema<{
            /**
             * The name of the user-defined component.
             * @example
             * "Link"
             */
            readonly name: StringSchema<undefined>;
            /**
             * The ESQuery selector to select the component precisely.
             * @example
             * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
             */
            readonly selector: OptionalSchema<StringSchema<undefined>, never>;
            /**
             * The name of the built-in component that the user-defined component represents.
             * @example
             * "a"
             */
            readonly as: OptionalSchema<StringSchema<undefined>, never>;
            /**
             * Pre-defined attributes that are used in the user-defined component.
             * @example
             * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
             */
            readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
                /**
                 * The name of the attribute in the user-defined component.
                 * @example
                 * "to"
                 */
                readonly name: StringSchema<undefined>;
                /**
                 * The name of the attribute in the built-in component.
                 * @example
                 * "href"
                 */
                readonly as: OptionalSchema<StringSchema<undefined>, never>;
                /**
                 * Whether the attribute is controlled or not in the user-defined component.
                 * @example
                 * `true`
                 */
                readonly controlled: OptionalSchema<BooleanSchema<undefined>, never>;
                /**
                 * The default value of the attribute in the user-defined component.
                 * @example
                 * `"/"`
                 */
                readonly defaultValue: OptionalSchema<StringSchema<undefined>, never>;
            }, undefined>, undefined>, never>;
        }, undefined>, undefined>, never>;
        /**
         * A object of aliases for React built-in hooks.
         * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
         * @example `{ useLayoutEffect: ["useIsomorphicLayoutEffect"] }`
         */
        readonly additionalHooks: OptionalSchema<ObjectSchema<{
            readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
            readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, never>;
        }, undefined>, never>;
    }, undefined>, never>;
}, undefined>, {}>;
type CustomHook = InferOutput<typeof CustomHookSchema>;
type CustomAttribute = InferOutput<typeof CustomAttributeSchema>;
type CustomComponent = InferOutput<typeof CustomComponentSchema>;
type CustomComponentNormalized = InferOutput<typeof CustomComponentNormalizedSchema>;
type ESLintReactSettings = InferOutput<typeof ESLintReactSettingsSchema>;
type ESLintSettings = InferOutput<typeof ESLintSettingsSchema>;
/**
 * This is an expanded version of `ESLintReactSettings` with all shorthand properties expanded.
 * @internal
 */
interface ESLintReactSettingsNormalized extends ESLintReactSettings {
    additionalComponents: CustomComponentNormalized[];
    components: Map<string, string>;
}

interface Dictionary<Type> {
  [key: string]: Type;
  [index: number]: Type;
}

type AnyFn = (...args: any[]) => any;

type Key = any[];
type RawKey = Key | IArguments;
type Value = any;

interface CacheSnapshot {
  keys: Key[];
  size: number;
  values: Value[];
}

declare class Cache<Fn extends AnyFn> {
  readonly canTransformKey: boolean;
  readonly getKeyIndex: KeyIndexGetter;
  readonly options: NormalizedOptions<Fn>;
  readonly shouldCloneArguments: boolean;
  readonly shouldUpdateOnAdd: boolean;
  readonly shouldUpdateOnChange: boolean;
  readonly shouldUpdateOnHit: boolean;

  /**
   * The prevents call arguments which have cached results.
   */
  keys: Key[];
  /**
   * The results of previous cached calls.
   */
  values: Value[];

  constructor(options: NormalizedOptions<Fn>);

  /**
   * The number of cached [key,value] results.
   */
  get size(): number;

  /**
   * A copy of the cache at a moment in time. This is useful
   * to compare changes over time, since the cache mutates
   * internally for performance reasons.
   */
  get snapshot(): CacheSnapshot;

  /**
   * Order the array based on a Least-Recently-Used basis.
   */
  orderByLru(key: Key, value: Value, startingIndex: number): void;

  /**
   * Update the promise method to auto-remove from cache if rejected, and
   * if resolved then fire cache hit / changed.
   */
  updateAsyncCache(memoized: Memoized<Fn>): void;
}

type EqualityComparator = (object1: any, object2: any) => boolean;

type MatchingKeyComparator = (key1: Key, key2: RawKey) => boolean;

type CacheModifiedHandler<Fn extends AnyFn> = (
  cache: Cache<Fn>,
  options: NormalizedOptions<Fn>,
  memoized: Memoized<Fn>,
) => void;

type KeyTransformer = (args: Key) => Key;

type KeyIndexGetter = (keyToMatch: RawKey) => number;

interface StandardOptions<Fn extends AnyFn> {
  isEqual?: EqualityComparator;
  isMatchingKey?: MatchingKeyComparator;
  isPromise?: boolean;
  maxSize?: number;
  onCacheAdd?: CacheModifiedHandler<Fn>;
  onCacheChange?: CacheModifiedHandler<Fn>;
  onCacheHit?: CacheModifiedHandler<Fn>;
  transformKey?: KeyTransformer;
}

interface Options<Fn extends AnyFn>
  extends StandardOptions<Fn>,
    Dictionary<any> {}

interface NormalizedOptions<Fn extends AnyFn> extends Options<Fn> {
  isEqual: EqualityComparator;
  isPromise: boolean;
  maxSize: number;
}

type Memoized<Fn extends AnyFn> = Fn &
  Dictionary<any> & {
    cache: Cache<Fn>;
    fn: Fn;
    isMemoized: true;
    options: NormalizedOptions<Fn>;
  };

/**
Matches any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

@category Type
*/
type Primitive =
	| null
	| undefined
	| string
	| number
	| boolean
	| symbol
	| bigint;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
Matches any primitive, `void`, `Date`, or `RegExp` value.
*/
type BuiltIns = Primitive | void | Date | RegExp;

/**
@see PartialDeep
*/
type PartialDeepOptions = {
	/**
	Whether to affect the individual elements of arrays and tuples.

	@default false
	*/
	readonly recurseIntoArrays?: boolean;
};

/**
Create a type from another type with all keys and nested keys set to optional.

Use-cases:
- Merging a default settings/config object with another object, the second object would be a deep partial of the default object.
- Mocking and testing complex entities, where populating an entire object with its keys would be redundant in terms of the mock or test.

@example
```
import type {PartialDeep} from 'type-fest';

const settings: Settings = {
	textEditor: {
		fontSize: 14;
		fontColor: '#000000';
		fontWeight: 400;
	}
	autocomplete: false;
	autosave: true;
};

const applySavedSettings = (savedSettings: PartialDeep<Settings>) => {
	return {...settings, ...savedSettings};
}

settings = applySavedSettings({textEditor: {fontWeight: 500}});
```

By default, this does not affect elements in array and tuple types. You can change this by passing `{recurseIntoArrays: true}` as the second type argument:

```
import type {PartialDeep} from 'type-fest';

interface Settings {
	languages: string[];
}

const partialSettings: PartialDeep<Settings, {recurseIntoArrays: true}> = {
	languages: [undefined]
};
```

@category Object
@category Array
@category Set
@category Map
*/
type PartialDeep<T, Options extends PartialDeepOptions = {}> = T extends BuiltIns | (((...arguments_: any[]) => unknown)) | (new (...arguments_: any[]) => unknown)
	? T
	: T extends Map<infer KeyType, infer ValueType>
		? PartialMapDeep<KeyType, ValueType, Options>
		: T extends Set<infer ItemType>
			? PartialSetDeep<ItemType, Options>
			: T extends ReadonlyMap<infer KeyType, infer ValueType>
				? PartialReadonlyMapDeep<KeyType, ValueType, Options>
				: T extends ReadonlySet<infer ItemType>
					? PartialReadonlySetDeep<ItemType, Options>
					: T extends object
						? T extends ReadonlyArray<infer ItemType> // Test for arrays/tuples, per https://github.com/microsoft/TypeScript/issues/35156
							? Options['recurseIntoArrays'] extends true
								? ItemType[] extends T // Test for arrays (non-tuples) specifically
									? readonly ItemType[] extends T // Differentiate readonly and mutable arrays
										? ReadonlyArray<PartialDeep<ItemType | undefined, Options>>
										: Array<PartialDeep<ItemType | undefined, Options>>
									: PartialObjectDeep<T, Options> // Tuples behave properly
								: T // If they don't opt into array testing, just use the original type
							: PartialObjectDeep<T, Options>
						: unknown;

/**
Same as `PartialDeep`, but accepts only `Map`s and as inputs. Internal helper for `PartialDeep`.
*/
type PartialMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> = {} & Map<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `Set`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialSetDeep<T, Options extends PartialDeepOptions> = {} & Set<PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlyMap`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlyMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> = {} & ReadonlyMap<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlySet`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlySetDeep<T, Options extends PartialDeepOptions> = {} & ReadonlySet<PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `object`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialObjectDeep<ObjectType extends object, Options extends PartialDeepOptions> = {
	[KeyType in keyof ObjectType]?: PartialDeep<ObjectType[KeyType], Options>
};

/**
 * The initial settings for "react-x".
 */
declare const INITIAL_ESLINT_REACT_SETTINGS: {
    readonly skipImportCheck: false;
};
/**
 * Unsafely casts settings from a data object from `context.settings`.
 * @internal
 * @param data The data object.
 * @returns settings The settings.
 */
declare function unsafeReadSettings(data: unknown): PartialDeep<ESLintReactSettings>;
/**
 * Decodes settings from a data object from `context.settings`.
 * @internal
 * @param data The data object.
 * @returns settings The settings.
 */
declare const decodeSettings: Memoized<(data: unknown) => {
    readonly skipImportCheck: boolean;
    readonly importSource?: string;
    readonly jsxPragma?: string;
    readonly jsxPragmaFrag?: string;
    readonly polymorphicPropName?: string;
    readonly strict?: boolean;
    readonly version?: string;
    readonly additionalComponents?: {
        name: string;
        as?: string;
        selector?: string;
        attributes?: {
            name: string;
            as?: string;
            controlled?: boolean;
            defaultValue?: string;
        }[];
    }[];
    readonly additionalHooks?: {
        use?: string[];
        useActionState?: string[];
        useCallback?: string[];
        useContext?: string[];
        useDebugValue?: string[];
        useDeferredValue?: string[];
        useEffect?: string[];
        useId?: string[];
        useImperativeHandle?: string[];
        useInsertionEffect?: string[];
        useLayoutEffect?: string[];
        useMemo?: string[];
        useOptimistic?: string[];
        useReducer?: string[];
        useRef?: string[];
        useState?: string[];
        useSyncExternalStore?: string[];
        useTransition?: string[];
    };
}>;
/**
 * Normalizes the settings by converting all shorthand properties to their full form.
 * @param settings The settings.
 * @returns The normalized settings.
 * @internal
 */
declare const normalizeSettings: Memoized<(settings: ESLintReactSettings) => {
    readonly additionalComponents: CustomComponentNormalized[];
    readonly components: Map<string, string>;
    readonly skipImportCheck: boolean;
    readonly importSource?: string;
    readonly jsxPragma?: string;
    readonly jsxPragmaFrag?: string;
    readonly polymorphicPropName?: string;
    readonly strict?: boolean;
    readonly version?: string;
    readonly additionalHooks?: {
        use?: string[];
        useActionState?: string[];
        useCallback?: string[];
        useContext?: string[];
        useDebugValue?: string[];
        useDeferredValue?: string[];
        useEffect?: string[];
        useId?: string[];
        useImperativeHandle?: string[];
        useInsertionEffect?: string[];
        useLayoutEffect?: string[];
        useMemo?: string[];
        useOptimistic?: string[];
        useReducer?: string[];
        useRef?: string[];
        useState?: string[];
        useSyncExternalStore?: string[];
        useTransition?: string[];
    };
}>;
declare function findAttrInCustomAttributes(name: string, attributes: CustomAttribute[]): readonly [string, string | undefined] | readonly [string];
/**
 * A helper function to define settings for "react-x" with type checking in JavaScript files.
 * @param settings The settings.
 * @returns The settings.
 */
declare const defineSettings: (settings: ESLintReactSettings) => ESLintReactSettings;
declare module "@typescript-eslint/utils/ts-eslint" {
    interface SharedConfigurationSettings {
        "react-x"?: Partial<ESLintReactSettings>;
    }
}

export { type CustomAttribute, CustomAttributeSchema, type CustomComponent, type CustomComponentNormalized, CustomComponentNormalizedSchema, CustomComponentSchema, type CustomHook, CustomHookSchema, type ESLintReactSettings, type ESLintReactSettingsNormalized, ESLintReactSettingsSchema, type ESLintSettings, ESLintSettingsSchema, GITHUB_URL, HOST_HTML_COMPONENT_TYPES, HOST_SVG_COMPONENT_TYPES, INITIAL_ESLINT_REACT_SETTINGS, NPM_SCOPE, REACT_BUILD_IN_HOOKS, RE_CAMEL_CASE, RE_CONSTANT_CASE, RE_JAVASCRIPT_PROTOCOL, RE_KEBAB_CASE, RE_PASCAL_CASE, RE_SNAKE_CASE, WEBSITE_URL, createRuleForPlugin, decodeSettings, defineSettings, findAttrInCustomAttributes, normalizeSettings, unsafeReadSettings };
